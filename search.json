[{"path":"/articles/B-choose_k.html","id":"context-motivation","dir":"Articles","previous_headings":"","what":"Context & motivation","title":"Choosing k -- an eigenproblem","text":"One novel features plmm package way methods address relationships among samples (e.g., patients/participants) data. Unlike mixed models packages like lme4, package based relationships grouping factor. Rather, relationships described matrix cell values capturing degree relationship among pair samples. Let \\(\\mathbf{X}\\) represent \\(n \\times p\\) design matrix data, let \\(\\tilde{\\mathbf{X}}\\) standardized \\(\\mathbf{X}\\) [1]. call \\(n \\times n\\) relationship matrix \\(\\mathbf{K}\\). default, \\(\\mathbf{K}\\) estimated data using data using \\(\\mathbf{K} = \\frac{1}{p} \\tilde{\\mathbf{X}}\\tilde{\\mathbf{X}}^\\top\\) [2]. rotation used plmm_prep() (internal function plmm) requires singular value decomposition (SVD) \\(\\mathbf{K}\\). becomes expensive calculation \\(n\\) large. improve computational time calculation, include optional argument \\(k\\) plmm() function – \\(k\\) parameter invoke truncated SVD. truncated SVD matrix shown optimal rank \\(k\\) approximation matrix (Eckart-Young-Mirsky theorem) [3]. use \\(\\mathbf{}_k\\) represent rank \\(k\\) approximation \\(\\mathbf{K}\\), implement approximation using truncated SVD using RSpectra::svds(). using truncated SVD can improve computational time orders magnitude, approach raises question choose appropriate value \\(k\\). choice one lends ‘rule thumb’ – may \\(k\\) takes approximate SVD \\(\\mathbf{K}\\) well depends (1) makeup specific data (2) user’s definition ‘close’ approximation. help users choose suitable \\(k\\) value use, offer function choose_k(), describe extended example. NOTE: (2024/01/02) latest simulations showing truncating SVD can worsen prediction performance, especially BLUP prediction method. using \\(k < \\text{min}(n,p)\\), make sure keep checking prediction error false discovery rate order assess impact truncated SVD.","code":""},{"path":"/articles/B-choose_k.html","id":"what-this-looks-like-in-practice","dir":"Articles","previous_headings":"","what":"What this looks like in practice","title":"Choosing k -- an eigenproblem","text":"Consider admix genotype data simulated continuous outcome. Suppose want approximate \\(\\mathbf{K}\\). use following: see starting value \\(k\\) 19 – default, choose_k() makes following ‘decisions’: starting value \\(k\\) set tenth \\(n\\) value. controlled start argument. Similarly, default stepsize also one tenth \\(n\\) value. controlled step argument. metric used assess quality approximation Frobenius norm. controlled type argument (see Matrix::norm). \\(\\epsilon\\) value used determine \\(\\delta \\equiv \\frac{||\\mathbf{K} - \\mathbf{}_k||_{\\text{F}}}{||\\mathbf{K}||_{\\text{F}}}\\) satisfactorily small enough automatically set 2. controlled eps argument. user wants smaller \\(\\epsilon\\) start higher value, another option: Notice apparent ‘tweaks’ parameters notable impact choice \\(k\\) – balance parameters art science. can look \\(\\mathbf{}_k\\) matrices produced approximations , comparing true \\(\\mathbf{K}\\) (far right):  Now approximations, can use cv.plmm see results:","code":"approx1 <- choose_k(X = admix$X, returnKapprox = T, returnK = T) #>  #> Starting k value is 19 #> Step size is 19 #> Calcuating the relatedness matrix #> Stepping up to next k value: k = 38 #> Stepping up to next k value: k = 57 #> Stepping up to next k value: k = 76 #> K approximation within specified epsilon reached at k = 76 approx2 <- choose_k(X = admix$X, start = 30, eps = 0.05, returnKapprox = T) #>  #> Starting k value is 30 #> Step size is 19 #> Calcuating the relatedness matrix #> Stepping up to next k value: k = 49 #> Stepping up to next k value: k = 68 #> Stepping up to next k value: k = 87 #> K approximation within specified epsilon reached at k = 87 par(mfrow=c(1,3)) corrplot(cov2cor(approx1$K_approx),          title = \"Approx. 1\",          mar = c(0,0,2,0),          tl.col = 'grey40',          addgrid.col = NA,           tl.pos = \"n\") corrplot(cov2cor(approx2$K_approx),          title = \"Approx. 2\",          mar = c(0,0,2,0),          tl.col = 'grey40',          addgrid.col = NA,           tl.pos = \"n\") corrplot(cov2cor(approx1$K),          title = \"True K\",          mar = c(0,0,2,0),          tl.col = 'grey40',          addgrid.col = NA,           tl.pos = \"n\") fit1 <- cv.plmm(X = admix$X, y = admix$y, K = approx1$K_svd) fit2 <- cv.plmm(X = admix$X, y = admix$y, K = approx2$K_svd)  par(mfrow=c(1,2)) plot(fit1) plot(fit2) summary(fit1) #> MCP-penalized model with n=197 and p=100 #> At minimum cross-validation error (lambda=0.1135): #> ------------------------------------------------- #>   Nonzero coefficients: 40 #>   Cross-validation error (deviance): 3.23 #>   Scale estimate (sigma): 1.798 summary(fit2) #> MCP-penalized model with n=197 and p=100 #> At minimum cross-validation error (lambda=0.1361): #> ------------------------------------------------- #>   Nonzero coefficients: 30 #>   Cross-validation error (deviance): 3.24 #>   Scale estimate (sigma): 1.799"},{"path":"/articles/B-choose_k.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Choosing k -- an eigenproblem","text":"[1] Reisetter, . C., & Breheny, P. (2021). Penalized linear mixed models structured genetic data. Genetic Epidemiology, 45(5), 427-444. [2] CITATION NEEDED standardization [3] Eckart, C., & Young, G. (1936). approximation one matrix another lower rank. Psychometrika, 1(3), 211-218.","code":""},{"path":"/articles/C-explore_options.html","id":"options-for-k-matrix","dir":"Articles","previous_headings":"","what":"Options for K matrix","title":"Exploring different modeling options","text":"One ‘coolest’ aspects plmm approach ability incorporate complex relationships model-fitting process. framework, relational structure data set represented matrix call \\(\\mathbf{K}\\). Imagine matrix quilt symmetric, checkered pattern. complex relational structure data, intricate pattern quilt becomes. relational structure data set include broad loosely related groups, (like ancestry groups), smaller highly correlated groups (like family units).","code":""},{"path":"/articles/C-explore_options.html","id":"structure","dir":"Articles","previous_headings":"Options for K matrix","what":"Structure","title":"Exploring different modeling options","text":"number observations (e.g., number participants) increases, computational time needed calculate entire \\(\\mathbf{K}\\) increases exponentially. reason, plmm() several options approximating \\(\\mathbf{K}\\). First, research contexts may appropriate assume data unrelated observations. cases, plmm() offers argument diag_K = T. use simplest possible ‘quilt pattern’, \\(\\mathbf{K} = \\mathbf{}_n\\) \\(n\\) number observations. can visualize impact two approaches choosing \\(\\mathbf{K}\\): left default option (relatedness_mat()), right option diag_K = T.","code":"# add this plot  fit_admix1 <- plmm(X = admix$X, y = admix$y) fit_admix2 <- plmm(X = admix$X, y = admix$y, diag_K = TRUE) par(mfrow=c(1,2)) plot(fit_admix1);plot(fit_admix2)"},{"path":"/articles/C-explore_options.html","id":"svd-implementation","dir":"Articles","previous_headings":"Options for K matrix","what":"SVD implementation","title":"Exploring different modeling options","text":"computation associated calculating \\(\\mathbf{K}\\) can become quite expensive, code illustrates:  can use choose_k() implement truncated singular value decomposition (SVD). shown via RSpectra::svds().","code":"#TODO: add these plots  K_dim <- c(100, 1000, 1500, 2000, 3000, 4000) true_times <- approx_times <- rep(NA, length(K_dim)) pb <- txtProgressBar(min = 1, max = length(K_dim), initial = 1, style = 3) #>    |                                                                               |                                                                      |   0% for (i in 1:length(K_dim)){   n <- K_dim[i]   true_times[i] <- svd(relatedness_mat(X = matrix(rnorm(n, 10), n, 10))) |>      system.time()    approx_times[i] <- RSpectra::svds(relatedness_mat(X = matrix(rnorm(n, 10), n, 10)),                                     k = floor(0.1*n)) |> system.time()    setTxtProgressBar(pb, i) } #>    |                                                                               |==============                                                        |  20%   |                                                                               |============================                                          |  40%   |                                                                               |==========================================                            |  60%   |                                                                               |========================================================              |  80%   |                                                                               |======================================================================| 100%  K_dat <- data.frame(true_times, approx_times, K_dim) ggplot(K_dat,        aes(x = K_dim)) +    geom_line(aes(y = true_times)) +    geom_line(aes(y = approx_times), linetype = 'dashed') +    labs(x = \"nrow(X): the dimension of the K matrix\",        y = \"SVD time in seconds\")"},{"path":"/articles/C-explore_options.html","id":"options-for-type-in-prediction","dir":"Articles","previous_headings":"","what":"Options for ‘type’ in prediction","title":"Exploring different modeling options","text":"PLMMs (well contexts), goal model building predict outcomes new data \\(X_2\\) based data outcomes \\(X_1, y_1\\). package offers two options prediction, ‘lp’ ‘blup’, user may specify via type argument cv.plmm() related functions. LP acronym “Linear Predictor” BLUP acronym Best Linear Unbiased Predictor. linear predictor (LP) \\(X_2 \\hat \\beta(\\lambda)\\), whereas Best Linear Unbiased Predictor (BLUP) \\(X_2 \\hat \\beta(\\lambda) + V_{21} V_{11}^{\\frac{-1}{2}}(\\tilde y_1 - \\tilde X_1 \\hat \\beta(\\lambda))\\), : \\(V_{n \\times n} \\equiv \\eta \\mathbf{K} + (1 - \\eta)\\mathbf{}_n\\) matrix describing correlation among \\(n\\) observations \\(X\\). matrix re-expressed \\(V_{n \\times n} \\equiv \\eta*(U \\text{diag}(S)U^\\top) + (1 - \\eta)I_n\\) via singular value decomposition. \\(\\tilde X_1\\) \\(\\tilde y_1\\) standardized rotated design matrix outcomes. (bullet work progress… need think .) symbol \\(\\eta\\) represents percentage \\(\\text{Var}(y)\\) attributable additive effects features (context genetics, narrow-sense heritability). \\(\\eta\\) also captures signal--noise ratio (SNR) data-generating mechanism (model). estimate \\(\\eta\\) \\(\\hat \\eta = \\text{argmin} \\ell (U, S, y)\\), value minimizes log-likelihood function (see estimate_eta() documentation details). Note BLUP includes LP first term, adds second term representing predicted random effect. means BLUP accounts covariance structure data, whereas LP incorporate structure. can compare results options :","code":"set.seed(615) cv_admix1 <- cv.plmm(X = admix$X, y = admix$y) set.seed(615) cv_admix1_blup <- cv.plmm(X = admix$X, y = admix$y, type = \"blup\")  par(mfrow=c(1,2)); plot(cv_admix1); plot(cv_admix1_blup) summary(cv_admix1);summary(cv_admix1_blup) #> MCP-penalized model with n=197 and p=100 #> At minimum cross-validation error (lambda=0.1584): #> ------------------------------------------------- #>   Nonzero coefficients: 25 #>   Cross-validation error (deviance): 3.36 #>   Scale estimate (sigma): 1.832 #> MCP-penalized model with n=197 and p=100 #> At minimum cross-validation error (lambda=0.1632): #> ------------------------------------------------- #>   Nonzero coefficients: 25 #>   Cross-validation error (deviance): 2.77 #>   Scale estimate (sigma): 1.664"},{"path":"/articles/C-explore_options.html","id":"options-for-looking-at-bias-and-variance","dir":"Articles","previous_headings":"","what":"Options for looking at bias and variance","title":"Exploring different modeling options","text":"may interest examine bias variance result cross-validated model fitting. cv.plmm() option returnBiasDetails; set TRUE, make returned object include bias (vector) loss (matrix). Moreover, plmm model fit, function v_hat construct approximated matrix \\(\\mathbf{\\hat V} \\equiv \\eta \\mathbf{K} + (1 - \\eta)\\mathbf{}_n\\).","code":""},{"path":"/articles/D-deconfounding.html","id":"context","dir":"Articles","previous_headings":"","what":"Context","title":"Deconfounding","text":"want explore different types confounding impact PLMMs — questions mind include: PLMM perform well? perform poorly? PLMM compare PCA different data contexts? PLMM uses PCs fixed effects – sense, ‘hybrid’ approach – way approach deconfounding data complex structure?","code":""},{"path":"/articles/D-deconfounding.html","id":"starting-with-some-test-data","dir":"Articles","previous_headings":"","what":"Starting with some test data","title":"Deconfounding","text":"Let’s compare three lasso models: glmnet, plmm linear predictor (default), plmm BLUP option.","code":"library(glmnet) #> Loading required package: Matrix #> Loaded glmnet 4.1-8 gb <- function(n=100, p=256, s=4, gamma=6, beta=2, B=20) {   mu <- matrix(rnorm(B*p), B, p)   z <- rep(1:B, each=n/B)   X <- matrix(rnorm(n*p), n, p) + mu[z,] |>     ncvreg::std()   b <- rep(c(beta, 0), c(s, p-s))   g <- seq(-gamma, gamma, length=B)   y <- X %*% b + g[z]   Z <- model.matrix(~0+factor(z))   list(y=y, X=X, beta=b, Z=Z, gamma=g, mu=mu, id=z) } l <- gb() cvg <- cv.glmnet(l$X, l$y) cvp <- cv.plmm(l$X, l$y, penalty='lasso') cvp_blup <- cv.plmm(l$X, l$y, penalty='lasso',                     type = 'blup',                     returnBiasDetails = TRUE)  # look at K -- note that this data scenario has a 'finer' population structure library(corrplot) #> corrplot 0.92 loaded corrplot(relatedness_mat(l$X), is.corr = F, tl.pos = \"n\")"},{"path":"/articles/D-deconfounding.html","id":"mspe","dir":"Articles","previous_headings":"Starting with some test data","what":"MSPE","title":"Deconfounding","text":"mean squared prediction error glmnet plmm, adding blup option makes improvement:","code":"min(cvg$cvm) #> [1] 3.846428 min(cvp$cve) #> [1] 4.211199 min(cvp_blup$cve) #> [1] 2.819861"},{"path":"/articles/D-deconfounding.html","id":"mse","dir":"Articles","previous_headings":"Starting with some test data","what":"MSE","title":"Deconfounding","text":"mean squared error, see \\(\\hat \\beta\\) better plmm, better still plmm + BLUP.","code":"crossprod(l$beta - coef(cvg)[-1]) |> drop() #> [1] 2.720244 crossprod(l$beta - coef(cvp)[-1]) |> drop() #> [1] 1.983359 crossprod(l$beta - coef(cvp_blup)[-1]) |> drop() #> [1] 1.334551"},{"path":"/articles/E-mfdr.html","id":"background-and-motivation","dir":"Articles","previous_headings":"","what":"Background and motivation","title":"Inference with marginal false discovery rates","text":"cross validation (cv.plmm()) serves method assessing model’s ability predict outcomes new data, cross validation geared towards making inferences \\(\\hat \\beta\\) values (coefficients) estimated model. use PLMM, often want answer questions like: “reliable selections made model chose?” “accurate estimated \\(\\hat \\beta\\) values?” One way address important questions marginal false discovery rates (mFdr). mFdr framework, can estimate mFdr value value \\(\\lambda\\) penalized regression model. gives another way compare different models. Instead just comparing cross-validation error, can also compare number probable false discoveries features chosen model. interested statistical theory behind method, recommend advisor’s free online lecture notes. article, use mfdr() function illustrate marginal false discovery rates can used compare models fit plmm() cv.plmm().","code":""},{"path":[]},{"path":"/articles/E-mfdr.html","id":"admix-data","dir":"Articles","previous_headings":"Examples","what":"Admix data","title":"Inference with marginal false discovery rates","text":"Let’s begin simple example using semi-simulated admix data. compare 3 models: fit 1: model singular values fixed effects. fit 2: model \\(k\\) singular values fixed effects. fit 3: model \\(k\\) singular values top 4 principal components fixed effects. fit, use cross validation select value \\(\\lambda\\) best prediction.","code":""},{"path":"/articles/E-mfdr.html","id":"fit-1","dir":"Articles","previous_headings":"Examples > Admix data","what":"fit 1","title":"Inference with marginal false discovery rates","text":"","code":"# construct a cross-validated lasso model  cv_fit1 <- cv.plmm(X = admix$X,               y = admix$y,               penalty = \"lasso\",               # remember to set a seed for reproducibility                seed = 26)  # look at results  fit1 <- cv_fit1$fit summary(cv_fit1) #> lasso-penalized model with n=197 and p=100 #> At minimum cross-validation error (lambda=0.0679): #> ------------------------------------------------- #>   Nonzero coefficients: 62 #>   Cross-validation error (deviance): 2.82 #>   Scale estimate (sigma): 1.680 # Calculate mFdr # head(mfdr(fit1)) mfdr1 <- mfdr(fit1)[cv_fit1$min,]"},{"path":"/articles/E-mfdr.html","id":"fit-2","dir":"Articles","previous_headings":"Examples > Admix data","what":"fit 2","title":"Inference with marginal false discovery rates","text":"","code":"# choose k  admix$k <- choose_k(X = admix$X, returnKapprox = T) #>  #> Starting k value is 19 #> Step size is 19 #> Calcuating the relatedness matrix #> Stepping up to next k value: k = 38 #> Stepping up to next k value: k = 57 #> Stepping up to next k value: k = 76 #> K approximation within specified epsilon reached at k = 76  # construct the model  cv_fit2 <- cv.plmm(X = admix$X,                    y = admix$y,                    K = admix$k$K_svd,                    seed = 26) #> Warning in set.seed(seed): '.Random.seed' is not an integer vector but of type #> 'NULL', so ignored  # look at results  fit2 <- cv_fit2$fit summary(cv_fit2) #> MCP-penalized model with n=197 and p=100 #> At minimum cross-validation error (lambda=0.1361): #> ------------------------------------------------- #>   Nonzero coefficients: 30 #>   Cross-validation error (deviance): 3.28 #>   Scale estimate (sigma): 1.812 # Calculate mFdr # head(mfdr(fit2)) mfdr2 <- mfdr(fit2)[cv_fit2$min,]"},{"path":"/articles/E-mfdr.html","id":"fit-3","dir":"Articles","previous_headings":"Examples > Admix data","what":"fit 3","title":"Inference with marginal false discovery rates","text":"principal components calculated, can now fit third model:","code":"# standardize design matrix and remove constant features  std_X <- ncvreg::std(admix$X) # calculate PCs from *standardized* data pca <- prcomp(std_X, center = F, scale = F) # plot the top 10 PCs in a scree plot  plot(x = 1:10,      y = 100 * proportions(pca$sdev[1:10]^2),      type = 'b',      ylab = 'Proportion of variance explained',      xlab = 'PC',      main = 'Scree Plot') # first 4 PCs explain most of the variance, so we will use these as fixed effects; this makes sense given the ancestry of the participants  pca_dat <- data.frame(race = admix$race, PC1 = pca$x[,1], PC2 = pca$x[, 2]) pca_plot <- ggplot(pca_dat, aes(x = PC1, y = PC2, col = as.factor(race))) +   geom_point() +   coord_fixed() plot(pca_plot) PCs <- pca$x # look at the PCs  # pca$x[1:5, 1:4] # incorporate 4 PCs as fixed effects  admix$X_plus_PCs <- cbind(PCs[,1:4], admix$X) # construct the model  cv_fit3 <- cv.plmm(X = admix$X_plus_PCs,                    y = admix$y,                    K = admix$k$K_svd,                    # make sure not to penalize fixed effects - we want to keep                     #  these in the model!                    penalty.factor = c(rep(0, 4), rep(1, ncol(admix$X))),                    seed = 26) #> Warning in set.seed(seed): '.Random.seed' is not an integer vector but of type #> 'NULL', so ignored  # look at results  fit3 <- cv_fit3$fit summary(cv_fit3) #> MCP-penalized model with n=197 and p=104 #> At minimum cross-validation error (lambda=0.2092): #> ------------------------------------------------- #>   Nonzero coefficients: 15 #>   Cross-validation error (deviance): 1.76 #>   Scale estimate (sigma): 1.326 # Calculate mFdr # head(mfdr(fit3)) mfdr3 <- mfdr(fit3)[cv_fit3$min,]"},{"path":"/articles/E-mfdr.html","id":"comparisons","dir":"Articles","previous_headings":"Examples","what":"Comparisons","title":"Inference with marginal false discovery rates","text":"Let’s compare results three models using admix data:  Comparing 3 models respective lambda.min values observations based plots output : * simulated outcome, 2 \\(\\beta\\) values truly nonzero (.e., 2 SNPs (SNPs 17 85) actually associated outcome - see data-raw/admix.R details). mind, results leave lot desired… still thinking /wondering explain phenomena. Marginal false discovery rates also give us another way select \\(\\lambda\\): instead choosing \\(\\lambda\\) value minimizes cross validation error, choose value limits mFdr certain level. can examine approach models fit :","code":"# columns are ordered by models 1-3 # rows are CV plots & coefficient path plots par(mfrow = c(2,3)) plot(cv_fit1); plot(cv_fit2); plot(cv_fit3) plot(fit1); plot(fit2); plot(fit3) admix_comparison <- as.data.table(rbind(mfdr1, mfdr2, mfdr3)) admix_comparison[, model := paste0(\"Model \", 1:3)] admix_comparison[, .(model, EF, S, mFDR)] |>   kable(digits=2, caption = \"Comparing 3 models at their respective lambda.min values\") # let's look at lambda where mFDR is smallest, instead of mFDR where lambda = lambda.min (minimum CVE)  # fit 1  (mfdr1[which.min(mfdr1$mFDR),])  # fit 2  (mfdr2[which.min(mfdr2$mFDR),])  # fit 3  (mfdr3[which.min(mfdr3$mFDR),])"},{"path":"/articles/E-mfdr.html","id":"penncath-data-high-dimensional","dir":"Articles","previous_headings":"Examples","what":"Penncath data (high dimensional)","title":"Inference with marginal false discovery rates","text":"Let’s similar model comparison, time using penncath_lite data. TODO: come back finish adding output later; data represent 1,401 individuals 4,367 SNPs GWAS study. sake example, let’s use hdl (high-density lipoprotein cholesterol) outcome.","code":"# preprocess PLINK files penncath_lite <- process_plink(   data_dir = plink_example(parent = TRUE),   prefix = \"penncath_lite\",   gz = TRUE, # NB: PLINK data that ships with package comes gzipped   impute = TRUE, # mode imputation is default    outfile = \"process_penncath\") # read in the data to global environment  # NB: this assumes article A ('Plink Files') has already been run.  # read in the data to global environment pen <- get_data(path = paste0(plink_example(parent = TRUE), \"/penncath_lite\"))  str(pen) # Three objects here # NB: the 'quiet' option in process_plink()  will silence the printed messages pen_cl <- read.csv(plink_example(path = 'penncath_clinical.csv'))  # for the sake of illustration, I use a simple mean imputation for the outcome  pen$y <- ifelse(is.na(pen_cl$hdl),                 mean(pen_cl$hdl, na.rm = T), pen_cl$hdl)"},{"path":"/articles/E-mfdr.html","id":"fit-1-1","dir":"Articles","previous_headings":"Examples > Penncath data (high dimensional)","what":"fit 1","title":"Inference with marginal false discovery rates","text":"Hmm – found mFdr 1 fit 1, great application standpoint. due true lack association SNPs HDL outcome, may also estimation issue. Remember, articles work progress… next model, use MCP instead lasso.","code":"# construct a cross-validated lasso model  cv_pen1 <- cv.plmm(X = pen$X,               y = pen$y,               penalty = \"lasso\",               # remember to set a seed for reproducibility                seed = 26)  # look at results  pen1 <- cv_pen1$fit summary(cv_pen1) # Calculate mFdr # head(mfdr(pen1)) (pen_mfdr1 <- mfdr(pen1)[cv_pen1$min,])"},{"path":"/articles/E-mfdr.html","id":"fit-2-1","dir":"Articles","previous_headings":"Examples > Penncath data (high dimensional)","what":"fit 2","title":"Inference with marginal false discovery rates","text":"","code":"pen$k <- choose_k(pen$X, returnKapprox = T)  cv_pen2 <- cv.plmm(X = pen$X,         y = pen$y,         K = pen$k$K_svd,         seed = 26)  pen2 <- cv_pen2$fit summary(cv_pen2) (pen_mfdr2 <- mfdr(pen2)[cv_pen2$min,])"},{"path":"/articles/E-mfdr.html","id":"fit-3-1","dir":"Articles","previous_headings":"Examples > Penncath data (high dimensional)","what":"fit 3","title":"Inference with marginal false discovery rates","text":"Finally, model ‘penncath’ data one time using sex first principal components","code":"pen$std_X <- ncvreg::std(pen$X) pen_pca <- prcomp(pen$std_X, center = F, scale. = F)  # scree plot  plot(x = 1:10,      y = 100 * proportions(pen_pca$sdev[1:10]^2),      type = 'b',      ylab = 'Proportion of variance explained',      xlab = 'PC',      main = 'Scree Plot')  # will use 10 PCs as fixed effects  pen_PCs <- pen_pca$x pen$X_plus_fixed_eff <- cbind(pen$fam[,c(\"sex\")], pen_PCs[,1:10], pen$X)  cv_pen3 <- cv.plmm(X = pen$X_plus_fixed_eff,                    y = pen$y,                     # start at 1200 based on result from the previous fit                    k = 1200,                    penalty.factor = c(rep(0,12), rep(1,ncol(pen$X))),                    seed = 26)  pen3 <- cv_pen3$fit summary(cv_pen3)  (pen_mfdr3 <- mfdr(pen3)[cv_pen3$min,])"},{"path":"/articles/E-mfdr.html","id":"comparisons-1","dir":"Articles","previous_headings":"Examples","what":"Comparisons","title":"Inference with marginal false discovery rates","text":"Comparing three fits ‘penncath’ data, can observe following: can also look mFDR changes among three models:","code":"par(mfrow = c(2,3)) plot(cv_pen1); plot(cv_pen2); plot(cv_pen3) plot(pen1); plot(pen2); plot(pen3) pen_comparison <- rbind(pen_mfdr1, pen_mfdr2, pen_mfdr3) |>   as.data.table(keep.rownames='lambda') pen_comparison[, model := paste0(\"Model \", 1:3)] pen_comparison[, .(model, EF, S, mFDR)] |>   kable(digits=3) compare_mfdr <- rbind(mfdr(pen1), mfdr(pen2), mfdr(pen3)) |>   as.data.table(keep.rownames='lambda') compare_mfdr[, model := c(rep(\"lasso\", 100),                           rep(\"MCP + trunc. SVD\", 100),                           rep('MCP + trunc. SVD + fixed eff', 100))] compare_mfdr[, log_lam := log(as.numeric(lambda))] ggplot(compare_mfdr, aes(x = log_lam, y = mFDR)) +    geom_line(aes(colour = model)) +    labs(x = expression(log(lambda)))"},{"path":"/articles/E-mfdr.html","id":"local-false-discovery-rates","dir":"Articles","previous_headings":"","what":"Local false discovery rates","title":"Inference with marginal false discovery rates","text":"beginning vignette, examined important questions inference. Let’s consider additional question often arises practice: “Can assess features (e.g., SNPs, predictors) likely false discoveries, features likely truly connected outcome care ?”. question individual features, rather model. One way address question local marginal false discovery rates (lmfdr). local mFdr framework takes mFdr feature level, mFdr value estimated \\(\\hat \\beta\\) penalized regression model. Using mFdr values, can rank selected features scale 0 1. feature mFdr value closer zero high probability associated outcome interest, whereas feature mFdr value closer 1 probably false discovery. Example come … future, want adapt ncvreg:::local_mfdr() work PLMMs.","code":""},{"path":"/articles/E-mfdr.html","id":"references-acknowledgements","dir":"Articles","previous_headings":"","what":"References & acknowledgements","title":"Inference with marginal false discovery rates","text":"mfdr() function incorporated plmm package based Ryan Miller’s joint work Patrick Breheny ncvreg::mfdr() package. read work, see Miller & Breheny (2023) Stats Medicine. Penncath data: data describe coronary artery disease outcomes PennCath study). data set subset much larger data set (original data 800K SNPs); chose create ‘lite’ version vignette purposes. information data set, refer original publication.","code":""},{"path":"/articles/getting-started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting started with plmm","text":"plmm R package created purpose fitting penalized regression models high dimensional data, particularly observations independent. kind data arises often context genetics (e.g. GWAS dealing population structure), motivation examples presented . time, package designed linear regression – , considering continuous (numeric) outcomes. future, like extend package handle logistic regression (handle dichotomous outcomes). Since focused penalized regression package, plmm offers 3 choices penalty: minimax concave (MCP), smoothly clipped absolute deviation (SCAD), least absolute shrinkage selection operator (LASSO). Much work package built concepts/techniques provided ncvreg package, whose author dissertation advisor. plmm currently includes two example data sets: admix small data set (197 observations, 100 SNPs) describes individuals different racial backgrounds. outcome admix simulated include population structure effects (.e. race/ethnicity impact SNP associations). penncath_lite (data coronary artery disease PennCath study) mid-sized, high dimensional data set (1401 observations, 4217 SNPs) several health outcomes well age sex information. data set subset much larger data set (original data 800K SNPs). information data set, refer original publication. overview, provide demo main functions plmm using admix data. Checkout ‘Working PLINK files’ vignette see demo processing penncath_lite data original PLINK file formats.","code":""},{"path":"/articles/getting-started.html","id":"basic-model-fitting","dir":"Articles","previous_headings":"","what":"Basic model fitting","title":"Getting started with plmm","text":"admix data already formatted elements \\(X\\) \\(y\\), can jump right call plmm: returned beta_vals item matrix whose rows \\(\\beta\\) coefficients whose columns represent values penalization parameter \\(\\lambda\\). default, plmm fits 100 values \\(\\lambda\\) (see setup_lambda function details). Note values \\(\\lambda\\), SNP 8 \\(\\hat \\beta = 0\\). SNP 8 constant feature, feature (column) whose values vary among members population. can summarize fit nth \\(\\lambda\\) value: can also plot path fit see model coefficients vary \\(\\lambda\\):","code":"admix_fit <- plmm(X = admix$X, y = admix$y) summary(admix_fit, lambda = admix_fit$lambda[95]) #> MCP-penalized regression model with n=, p=101 at lambda=0.0349 #> ------------------------------------------------- #> The model converged  #> ------------------------------------------------- #> # of non-zero coefficients:  80  #> ------------------------------------------------- admix_fit$beta_vals[1:10, 97:100] #>                    0.0328        0.0319        0.0309        0.0300 #> (Intercept) -3.646252e+14 -3.641797e+14 -3.635221e+14 -3.606863e+14 #> Snp1        -4.569951e-01 -4.578702e-01 -4.588573e-01 -4.620568e-01 #> Snp2         1.290528e-01  1.339690e-01  1.387797e-01  1.441289e-01 #> Snp3         5.664828e+00  5.663927e+00  5.662990e+00  5.646975e+00 #> Snp4         4.066041e-01  4.062007e-01  4.055993e-01  4.037997e-01 #> Snp5        -9.689787e-01 -9.721192e-01 -9.753301e-01 -9.680589e-01 #> Snp6        -6.066207e-02 -6.244764e-02 -6.436125e-02 -6.626384e-02 #> Snp7         1.126228e-01  1.174248e-01  1.220051e-01  1.265012e-01 #> Snp8         0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00 #> Snp9         8.803933e-01  8.810233e-01  8.813319e-01  8.776630e-01 # for n = 25  summary(admix_fit, lambda = admix_fit$lambda[25]) #> MCP-penalized regression model with n=, p=101 at lambda=0.2901 #> ------------------------------------------------- #> The model converged  #> ------------------------------------------------- #> # of non-zero coefficients:  9  #> ------------------------------------------------- plot(admix_fit)"},{"path":"/articles/getting-started.html","id":"cross-validation","dir":"Articles","previous_headings":"","what":"Cross validation","title":"Getting started with plmm","text":"select \\(\\lambda\\) value, often use cross validation. example using cv.plmm select \\(\\lambda\\) minimizes cross-validation error: can also plot cross-validation error (CVE) versus \\(\\lambda\\) (log scale):","code":"admix_cv <- cv.plmm(X = admix$X, y = admix$y) admix_cv_s <- summary(admix_cv, lambda = \"min\") print(admix_cv_s) #> MCP-penalized model with n=197 and p=100 #> At minimum cross-validation error (lambda=0.1537): #> ------------------------------------------------- #>   Nonzero coefficients: 26 #>   Cross-validation error (deviance): 3.33 #>   Scale estimate (sigma): 1.824 plot(admix_cv)"},{"path":"/articles/getting-started.html","id":"predicted-values","dir":"Articles","previous_headings":"","what":"Predicted values","title":"Getting started with plmm","text":"predict() methods PLMMs development (working Best Linear Unbiased Predictor); example now: come….","code":"# make predictions for select lambda value(s) admix_pred1 <- predict(object = admix_fit,                        newX = admix$X,                        type = \"lp\",                        idx=98)"},{"path":"/articles/notation.html","id":"math-notation","dir":"Articles","previous_headings":"","what":"Math notation","title":"Notes on notation","text":"concepts need denote, order usage derivations. blocked sections corresponding steps model fitting process.","code":""},{"path":"/articles/notation.html","id":"statistical-model-the-overall-framework","dir":"Articles","previous_headings":"Math notation","what":"Statistical model (the overall framework)","title":"Notes on notation","text":"overall model can written \\[ \\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\mathbf{Z}\\boldsymbol{\\gamma} + \\boldsymbol{\\epsilon} \\] equivalently \\[ \\mathbf{y} = \\dot{\\mathbf{X}}\\dot{\\boldsymbol{\\beta}} + \\mathbf{u} + \\boldsymbol{\\epsilon} \\] : \\(\\mathbf{X}\\) \\(\\mathbf{y}\\) \\(n \\times p\\) design matrix data \\(n \\times 1\\) vector outcomes, respectively. , \\(n\\) number observations (e.g., number patients, number samples, etc.) \\(p\\) number features (e.g., number SNPs, number variables, number covariates, etc.). \\(\\dot{\\mathbf{X}}\\) column-standardized \\(\\mathbf{X}\\), \\(p\\) columns mean 0 standard deviation 1. Note: \\(\\dot{\\mathbf{X}}\\) excludes singular features (columns constants) original \\(\\mathbf{X}\\). \\(\\dot{\\boldsymbol{\\beta}}\\) represents coefficients standardized scale. \\(\\mathbf{Z}\\) \\(n \\times b\\) matrix indicators corresponding grouping structure, \\(\\boldsymbol{\\gamma}\\) vector values describing grouping associated \\(\\mathbf{y}\\). real data, values typically unknown. \\(\\boldsymbol{\\epsilon}\\) \\(n \\times 1\\) vector noise. define realized (empirical) relatedness matrix \\(\\mathbf{K} \\equiv \\frac{1}{p}\\dot{\\mathbf{X}}\\dot{\\mathbf{X}}^\\top\\) model assumes: \\(\\boldsymbol{\\epsilon} \\perp \\mathbf{u}\\) \\(\\boldsymbol{\\epsilon} \\sim N(0, \\sigma^2_{\\epsilon}\\mathbf{})\\) \\(\\mathbf{u} \\sim N(0, \\sigma^2_{s}\\mathbf{K})\\) assumptions, may write \\(\\mathbf{y} \\sim N(\\dot{\\mathbf{X}}\\dot{\\boldsymbol{\\beta}}, \\boldsymbol{\\Sigma})\\) Indices: \\(\\1,..., n\\) indexes observations \\(j \\1,..., p\\) indexes features \\(h \\1,..., b\\) indexes batches (e.g., different family groups, different data collection sites, etc.)","code":""},{"path":"/articles/notation.html","id":"decomposition-and-rotation-prep-and-first-part-of-fit","dir":"Articles","previous_headings":"Math notation","what":"Decomposition and rotation (prep and first part of fit)","title":"Notes on notation","text":"Beginning singular value decomposition, \\(\\mathbf{U}\\) \\(\\mathbf{d}\\) right singular vectors singular values \\(\\dot{\\mathbf{X}}\\), one obtain singular value decomposition (SVD), .e. \\(\\text{svd}(\\mathbf{X)} \\equiv \\mathbf{U}\\mathbf{D}\\mathbf{V}^\\top\\). elements \\(\\mathbf{d}\\) diagonal values \\(\\mathbf{D}\\). Note, random effect \\(\\mathbf{u}\\) distinct columns matrix \\(\\mathbf{U}\\). \\(k\\) represents number nonzero eigenvalues represented \\(\\mathbf{U}\\) \\(\\mathbf{d}\\), \\(k \\leq \\text{min}(n,p)\\). \\(\\mathbf{S} \\equiv \\frac{1}{p}\\mathbf{D}^2\\) \\(k \\times k\\) diagonal matrix whose diagonal values \\(\\frac{d_k^2}{p}\\). , \\(\\mathbf{K} \\equiv \\frac{1}{p}\\dot{\\mathbf{X}}\\dot{\\mathbf{X}}^{\\top}\\)often referred literature realized relatedness matrix (RRM) genomic relatedness matrix (GRM). \\(\\mathbf{K}\\) dimension \\(n \\times n\\). Note \\(\\mathbf{K}\\) can obtained SVD \\(\\dot{\\mathbf{X}}\\), .e., \\(\\mathbf{U}\\mathbf{S}\\mathbf{U}^{\\top}\\), \\(\\mathbf{S}\\) diagonal matrix whose diagonal values \\(\\frac{d_k^2}{p}\\). \\(\\eta\\) ratio \\(\\frac{\\sigma^2_s}{\\sigma^2_e + \\sigma^2_s}\\). estimate \\(\\hat{\\eta}\\) null model (details come). \\(\\mathbf{\\Sigma}\\) variance outcome, \\(\\mathbb{V}({\\mathbf{y}}) = \\eta \\mathbf{K} + (1 - \\eta)\\mathbf{}_n\\). \\(\\mathbf{w}\\) vector weights defined \\((\\eta\\mathbf{\\mathbf{s}} + (1-\\eta))^{-1/2}\\). values \\(\\mathbf{w}\\) nonzero values diagonal matrix \\(\\mathbf{W} \\equiv (\\eta\\mathbf{S} + (1 - \\eta)\\mathbf{})^{-1/2}\\). matrix used rotating ( preconditioning) data \\(\\mathbf{\\Sigma}^{-1/2} \\equiv \\mathbf{W}\\mathbf{U}^\\top\\). \\(\\tilde{\\dot{\\mathbf{X}}} \\equiv \\mathbf{W}\\mathbf{U}^\\top\\dot{\\mathbf{X}}\\) rotated data, data transformed scale. \\(\\tilde{\\mathbf{y}} \\equiv \\mathbf{\\Sigma}^{-1/2}\\mathbf{y}\\) outcome rotated scale. \\(\\ddot{\\tilde{\\mathbf{X}}}\\) standardized rotated data. Note: standardization involves scaling, centering. post-rotation standardization impacts estimated coefficients well; define \\({\\ddot{\\boldsymbol{\\beta}}}\\) estimated coefficients scale.","code":""},{"path":"/articles/notation.html","id":"model-fitting-with-penalization","dir":"Articles","previous_headings":"Math notation","what":"Model fitting with penalization","title":"Notes on notation","text":"fit \\(\\tilde{\\mathbf{y}} \\sim \\ddot{\\tilde{\\mathbf{X}}}\\) using penalized linear mixed model, obtain \\(\\hat{\\ddot{\\boldsymbol{\\beta}}}\\) estimated coefficients. penalty parameter values (e.g., values lasso tuning parameter) indexed \\(\\lambda_l \\1,..., t\\).","code":""},{"path":"/articles/notation.html","id":"rescaling-results-format","dir":"Articles","previous_headings":"Math notation","what":"Rescaling results (format)","title":"Notes on notation","text":"obtain estimated coefficients original scale, values estimated model must unscaled (‘untransformed’) twice: adjust post-rotation standardization, adjust pre-rotation standardization. process written \\(\\hat{\\ddot{\\boldsymbol{\\beta}}} \\rightarrow \\hat{\\dot{\\boldsymbol{\\beta}}} \\rightarrow \\hat{\\boldsymbol{\\beta}}\\).","code":""},{"path":"/articles/notation.html","id":"object-names-in-source-code","dir":"Articles","previous_headings":"","what":"Object names in source code","title":"Notes on notation","text":"code, denote objects way: \\(\\mathbf{X}\\) \\(\\mathbf{y}\\) X y \\(\\dot{\\mathbf{X}}\\) std_X \\(\\tilde{\\dot{\\mathbf{X}}}\\) rot_X \\(\\ddot{\\tilde{\\mathbf{X}}}\\) stdrot_X \\(\\dot{\\mathbf{X}}\\dot{\\boldsymbol{\\beta}}\\) Xb","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Anna C. Reisetter. Author. Patrick J. Breheny. Author. Tabitha K. Peter. Author, maintainer. Yujiing Lu. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Reisetter , Breheny P, Peter T, Lu Y (2024). plmm: Fit nonconvex-penalized linear mixed models account presence unobserved confounding effects. R package version 2.2.1.","code":"@Manual{,   title = {plmm: Fit nonconvex-penalized linear mixed models to account for the presence of unobserved confounding effects},   author = {Anna C. Reisetter and Patrick J. Breheny and Tabitha K. Peter and Yujiing Lu},   year = {2024},   note = {R package version 2.2.1}, }"},{"path":"/index.html","id":"welcome","dir":"","previous_headings":"","what":"Welcome","title":"Fit nonconvex-penalized linear mixed models to account for the presence of unobserved confounding effects","text":"plmm package contains functions fit penalized linear mixed models correct unobserved confounding effects. Documentation package progress.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Fit nonconvex-penalized linear mixed models to account for the presence of unobserved confounding effects","text":"install latest version package: description motivation functions package (along examples) refer second module GWAS data tutorial","code":"devtools::install_github(\"pbreheny/plmm\")"},{"path":"/index.html","id":"latest-changes","dir":"","previous_headings":"","what":"Latest changes","title":"Fit nonconvex-penalized linear mixed models to account for the presence of unobserved confounding effects","text":"newest features plmm : - version 2.2.0: parameter η longer estimated fold cross-validation version 2.1.0: new function mfdr() inference model coefficients. version 2.0.3: xgboost method now available process_plink(). Check documentation details. option regarded ‘beta-testing’ mode.","code":""},{"path":"/index.html","id":"note-on-branches","dir":"","previous_headings":"","what":"Note on branches","title":"Fit nonconvex-penalized linear mixed models to account for the presence of unobserved confounding effects","text":"branches repo organized following way: master main branch latest updates change_eigen_default development branch working change default approach calculating decomposition done internal function plmm_prep() order make faster. estimate_eta development branch working alternative approach estimating η. fbm development branch working extend current methods analyze data design matrix stored file-backed object (Filebacked Big Matrix, FBM). See package bigstatsr info objects. refine_workflow archived branch explored changing workflow make cross validation efficient. change involved moving rotation step plmm_prep(), instead step part model fitting plmm_fit(). found change compatible cross validation, reasons currently writing part paper. paper done, delete branch.","code":""},{"path":"/reference/admix.html","id":null,"dir":"Reference","previous_headings":"","what":"Admix: Semi-simulated SNP data — admix","title":"Admix: Semi-simulated SNP data — admix","text":"dataset containing 100 SNPs, demographic variable representing race, simulated outcome","code":""},{"path":"/reference/admix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Admix: Semi-simulated SNP data — admix","text":"","code":"admix"},{"path":"/reference/admix.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Admix: Semi-simulated SNP data — admix","text":"list 3 components X SNP matrix (197 observations 100 SNPs) y vector simulated (continuous) outcomes race vector racial group categorization: # 0 = African, 1 = African American, 2 = European, 3 = Japanese","code":""},{"path":"/reference/admix.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Admix: Semi-simulated SNP data — admix","text":"https://hastie.su.domains/CASI/","code":""},{"path":"/reference/choose_k.html","id":null,"dir":"Reference","previous_headings":"","what":"a function to choose k, the number of eigenvalues to use in truncated SVD — choose_k","title":"a function to choose k, the number of eigenvalues to use in truncated SVD — choose_k","text":"function choose k, number eigenvalues use truncated SVD","code":""},{"path":"/reference/choose_k.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"a function to choose k, the number of eigenvalues to use in truncated SVD — choose_k","text":"","code":"choose_k(   X,   start = NULL,   step = NULL,   eps = 0.1,   trace = TRUE,   type = \"F\",   returnKapprox = FALSE,   returnK = FALSE )"},{"path":"/reference/choose_k.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"a function to choose k, the number of eigenvalues to use in truncated SVD — choose_k","text":"X can either: fully-imputed design matrix, string specifying path .rds object created process_plink start starting number eigenvalues. Defaults floor(nrow(X)/10) step size (respect number observations) increments increase choosing k. Defaults floor(nrow(X)/10). eps percentage indicating largest permissible approximation error true approximate relatedness matrices. Defaults 0.1 (10% error). trace Logical: progress bars messages printed console? Defaults TRUE. type type norm use determining distance true approximate K. Defaults 'F', Frobenious norm. See Matrix::norm() details. returnKapprox Logical: addition list SVD components approximated K, approximation returned matrix? Defaults FALSE. returnK Logical: true K (relatedness_mat(X)) returned? Defaults FALSE.","code":""},{"path":"/reference/choose_k.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"a function to choose k, the number of eigenvalues to use in truncated SVD — choose_k","text":"list least 3 items: svd_K: list SVD components (s U) approximated relatedness matrix K can passed plmm() k, chosen number eigenvalues delt, distance true approximated K matrices chosen k k_vals, vector k values evaluated inv_delt_vals, vector 1-delta k values evaluated. See delta() details. optional: returnKapprox, K_approx returned optional: returnK, K returned","code":""},{"path":"/reference/choose_k.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"a function to choose k, the number of eigenvalues to use in truncated SVD — choose_k","text":"","code":"if (FALSE) { res <- choose_k(X = admix$X, start = 10, step = 10, trace = TRUE) plot(x = res$k_vals, y = res$inv_delt_vals, type = \"l\") }"},{"path":"/reference/coef.cv.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Coef method for ","title":"Coef method for ","text":"Coef method \"cv.plmm\" class","code":""},{"path":"/reference/coef.cv.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coef method for ","text":"","code":"# S3 method for cv.plmm coef(object, lambda, which = object$min, ...)"},{"path":"/reference/coef.cv.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coef method for ","text":"object object class \"cv.plmm.\" lambda numeric vector lambda values. Vector lambda indices coefficients return. Defaults lambda index minimum CVE. ... Additional arguments (used).","code":""},{"path":"/reference/coef.cv.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coef method for ","text":"","code":"if (FALSE) { cv_fit <- cv.plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X)) head(coef.cv.plmm(cv_fit)) }"},{"path":"/reference/coef.lmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Coef method for ","title":"Coef method for ","text":"Coef method \"lmm\" class","code":""},{"path":"/reference/coef.lmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coef method for ","text":"","code":"# S3 method for lmm coef(object, which = 1:length(object$beta_vals), ...)"},{"path":"/reference/coef.lmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coef method for ","text":"object object class \"lmm.\" Vector indices coefficients return. ... Additional arguments.","code":""},{"path":"/reference/coef.lmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coef method for ","text":"","code":"if (FALSE) { fit <- lmm(X = pedigree$X, y = pedigree$clinical$y, K = pedigree$K) coef.lmm(fit) }"},{"path":"/reference/coef.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Coef method for ","title":"Coef method for ","text":"Coef method \"plmm\" class","code":""},{"path":"/reference/coef.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coef method for ","text":"","code":"# S3 method for plmm coef(object, lambda, which = 1:length(object$lambda), drop = TRUE, ...)"},{"path":"/reference/coef.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coef method for ","text":"object object class \"plmm.\" lambda numeric vector lambda values. Vector lambda indices coefficients return. drop Logical. ... Additional arguments.","code":""},{"path":"/reference/coef.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coef method for ","text":"","code":"if (FALSE) { fit <- plmm(admix$X, admix$y) (coef.plmm(fit)[1:10, 1:5]) # TODO: in R CMD CHECK, this throws the error:  # could not find function \"coef.plmm\" }"},{"path":"/reference/convexMin.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate index for which objective function ceases to be locally convex — convexMin","title":"Calculate index for which objective function ceases to be locally convex — convexMin","text":"Calculate index objective function ceases locally convex","code":""},{"path":"/reference/convexMin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate index for which objective function ceases to be locally convex — convexMin","text":"","code":"convexMin(b, X, penalty, gamma, l2, family = \"gaussian\", penalty.factor)"},{"path":"/reference/convexMin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate index for which objective function ceases to be locally convex — convexMin","text":"b Matrix coefficient values. X Design matrix. penalty penalty applied model. Either \"MCP\", \"SCAD\", \"lasso\". gamma tuning parameter MCP/SCAD penalty. Default 3 MCP 3.7 SCAD. l2 L2. family \"gaussian\" currently supported. penalty.factor multiplicative factor penalty applied coefficient. supplied, penalty.factor must numeric vector length equal number columns X. purpose penalty.factor apply differential penalization coefficients thought likely others model. particular, penalty.factor can 0, case coefficient always model without shrinkage.","code":""},{"path":"/reference/cv.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation for plmm — cv.plmm","title":"Cross-validation for plmm — cv.plmm","text":"Performs k-fold cross validation lasso-, MCP-, SCAD-penalized penalized linear mixed models grid values regularization parameter lambda.","code":""},{"path":"/reference/cv.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation for plmm — cv.plmm","text":"","code":"cv.plmm(   X,   y,   k = NULL,   K = NULL,   diag_K = NULL,   eta_star = NULL,   penalty = c(\"MCP\", \"SCAD\", \"lasso\"),   penalty.factor = rep(1, ncol(X)),   type = \"lp\",   ...,   cluster,   nfolds = 10,   seed,   fold = NULL,   returnY = FALSE,   returnBiasDetails = FALSE,   trace = FALSE )"},{"path":"/reference/cv.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation for plmm — cv.plmm","text":"X Design matrix model fitting. May include clinical covariates non-SNP data. case, X_for_K supplied witha  matrix containing SNP data computation GRM. y Continuous outcome vector model fitting. k integer specifying number singular values used approximation rotated design matrix. argument passed RSpectra::svds(). Defaults min(n, p) - 1, n p dimensions standardized design matrix. K Similarity matrix, form (1) relatedness matrix estimated data (default), (2) user-supplied matrix, (3) user-supplied list components 'd' 'u' created choose_k(). diag_K Logical: K diagonal matrix? reflect observations unrelated, can treated unrelated. Defaults FALSE. eta_star Optional arg. plmm_prep. Defaults NULL. penalty penalty applied model. Either \"MCP\" (default), \"SCAD\", \"lasso\". penalty.factor Optional arg. plmm_prep. Defaults 1 predictors (except intercept). type character argument indicating returned predict.plmm. type == 'lp' predictions based linear predictor, $X beta$. type == 'blup' predictions based sum linear predictor estimated random effect (BLUP). Defaults 'lp'. ... Additional arguments plmm_fit cluster cv.plmm can run parallel across cluster using parallel package. cluster must set advance using makeCluster function package. cluster must passed cv.plmm. nfolds number cross-validation folds. Default 10. seed may set seed random number generator order obtain reproducible results. fold fold observation belongs . default observations randomly assigned. returnY cv.plmm return linear predictors cross-validation folds? Default FALSE; TRUE, return matrix element row , column j fitted value observation fold observation excluded fit, jth value lambda. returnBiasDetails Logical: cross-validation bias (numeric value) loss (n x p matrix) returned? Defaults FALSE. trace set TRUE, inform user progress announcing beginning CV fold. Default FALSE.","code":""},{"path":"/reference/cv.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validation for plmm — cv.plmm","text":"","code":"cv_fit <- cv.plmm(X = admix$X, y = admix$y, seed = 321) if (FALSE) { cv_s <- summary.cv.plmm(cv_fit, lambda = \"1se\") print(cv_s) plot(cv_fit) }"},{"path":"/reference/cvf.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation internal function for cv.plmm — cvf","title":"Cross-validation internal function for cv.plmm — cvf","text":"Internal function cv.plmm calls plmm fold subset original data.","code":""},{"path":"/reference/cvf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation internal function for cv.plmm — cvf","text":"","code":"cvf(i, fold, type, cv.args, estimated_V, ...)"},{"path":"/reference/cvf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation internal function for cv.plmm — cvf","text":"Fold number excluded fit. fold n-length vector fold-assignments. type character argument indicating returned predict.plmm. type == 'lp' predictions based linear predictor, $X beta$. type == 'individual' predictions based linear predictor plus estimated random effect (BLUP). cv.args List additional arguments passed plmm. estimated_V Estimated variance-covariance matrix using observations computing BLUP; NULL type = \"lp\" cv.plmm. ... Optional arguments predict.list","code":""},{"path":"/reference/delta.html","id":null,"dir":"Reference","previous_headings":"","what":"a helper function to calculate the 'distance' between 2 matrices — delta","title":"a helper function to calculate the 'distance' between 2 matrices — delta","text":"helper function calculate 'distance' 2 matrices","code":""},{"path":"/reference/delta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"a helper function to calculate the 'distance' between 2 matrices — delta","text":"","code":"delta(A, B, type = \"F\")"},{"path":"/reference/delta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"a helper function to calculate the 'distance' between 2 matrices — delta","text":"matrix compared B B second matrix (think approximation ) type String indicating type norm used. See Matrix::norm() details","code":""},{"path":"/reference/eigen_K.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to take the eigendecomposition of K\nNote: This is faster than taking SVD of X when p >> n — eigen_K","title":"A function to take the eigendecomposition of K\nNote: This is faster than taking SVD of X when p >> n — eigen_K","text":"function take eigendecomposition K Note: faster taking SVD X p >> n","code":""},{"path":"/reference/eigen_K.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to take the eigendecomposition of K\nNote: This is faster than taking SVD of X when p >> n — eigen_K","text":"","code":"eigen_K(std_X, p)"},{"path":"/reference/eigen_K.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to take the eigendecomposition of K\nNote: This is faster than taking SVD of X when p >> n — eigen_K","text":"std_X standardized design matrix p number columns unstandardized design matrix","code":""},{"path":"/reference/eigen_K.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to take the eigendecomposition of K\nNote: This is faster than taking SVD of X when p >> n — eigen_K","text":"list eigenvectors eigenvalues K","code":""},{"path":"/reference/estimate_eta.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate eta (to be used in rotating the data)\nThis function is called internally by plmm() — estimate_eta","title":"Estimate eta (to be used in rotating the data)\nThis function is called internally by plmm() — estimate_eta","text":"Estimate eta (used rotating data) function called internally plmm()","code":""},{"path":"/reference/estimate_eta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate eta (to be used in rotating the data)\nThis function is called internally by plmm() — estimate_eta","text":"","code":"estimate_eta(s, U, y, eta_star)"},{"path":"/reference/estimate_eta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate eta (to be used in rotating the data)\nThis function is called internally by plmm() — estimate_eta","text":"s singular values K, realized relationship matrix U left-singular vectors standardized design matrix y Continuous outcome vector.","code":""},{"path":"/reference/get_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Read in processed data\nThis function is intended to be called after process_plink() has been called once. — get_data","title":"Read in processed data\nThis function is intended to be called after process_plink() has been called once. — get_data","text":"Read processed data function intended called process_plink() called .","code":""},{"path":"/reference/get_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read in processed data\nThis function is intended to be called after process_plink() has been called once. — get_data","text":"","code":"get_data(path, returnX, trace = TRUE)"},{"path":"/reference/get_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read in processed data\nThis function is intended to be called after process_plink() has been called once. — get_data","text":"path file path RDS object containing processed data. add '.rds' extension path. returnX Logical: design matrix returned numeric matrix stored memory. default, FALSE object sizes exceeds 100 Mb. trace Logical: trace messages shown? Default TRUE.","code":""},{"path":"/reference/get_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read in processed data\nThis function is intended to be called after process_plink() has been called once. — get_data","text":"list four components: X, design matrix either (1) numeric matrix (2) filebacked matrix (FBM). See bigstatsr::FBM() bigsnpr::bigSnp-class documentation details. fam, data frame containing pedigree information (like .fam file PLINK) map, data frame containing feature information (like .bim file PLINK) constants_idx vector indicating columns X contain constant features (features variance).","code":""},{"path":"/reference/get_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read in processed data\nThis function is intended to be called after process_plink() has been called once. — get_data","text":"returned list, fam data sorted family individual, dplyr::arrange(family.ID, sample.ID). rows X sorted align order fam, rownames X sample ID.","code":""},{"path":"/reference/get_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read in processed data\nThis function is intended to be called after process_plink() has been called once. — get_data","text":"","code":"if (FALSE) { pen <- get_data(path = \"../temp_files/penncath_lite\", trace = TRUE) }"},{"path":"/reference/gic.html","id":null,"dir":"Reference","previous_headings":"","what":"General information criterion method of selecting lambda for ","title":"General information criterion method of selecting lambda for ","text":"General information criterion method selecting lambda \"plmm\" class","code":""},{"path":"/reference/gic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"General information criterion method of selecting lambda for ","text":"","code":"gic(fit, ic = c(\"bic\", \"hdbic\"), rot_X, rot_y, s)"},{"path":"/reference/gic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"General information criterion method of selecting lambda for ","text":"fit object class \"plmm\" svd_detail set TRUE (default) ic Information criterion used select lambda. Currently supports BIC HDBIC. Defaults BIC. rot_X Optional: Rotated design matrix including rotated intercept unpenalized columns, present. returned part plmm returnX == FALSE, must supplied explicitly. rot_y Optional: Rotated outcome vector. returned part plmm returnX == FALSE, must supplied explicitly. s Optional: Eigenvalues similarity matrix used model fitting. returned part plmm returnX == FALSE, must supplied explicitly.","code":""},{"path":"/reference/gic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"General information criterion method of selecting lambda for ","text":"","code":"fit <- plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X)) std_X <- ncvreg::std(admix$X) wUt <- diag(fit$s)%*%fit$U gic_res <- gic(fit = fit, ic = \"bic\", rot_X = wUt%*%std_X, rot_y = wUt%*%admix$y, s = fit$s) names(gic_res) #> [1] \"fit\"            \"lambda\"         \"nzero\"          \"gic\"            #> [5] \"lambda.min\"     \"lambda.min.idx\" range(gic_res$gic, na.rm = TRUE) # NAs will result from monomorphic SNPs #> [1] -549.38348  -36.91272"},{"path":"/reference/lamNames.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate nicely formatted lambda vec — lamNames","title":"Generate nicely formatted lambda vec — lamNames","text":"Generate nicely formatted lambda vec","code":""},{"path":"/reference/lamNames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate nicely formatted lambda vec — lamNames","text":"","code":"lamNames(l)"},{"path":"/reference/lamNames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate nicely formatted lambda vec — lamNames","text":"l Vector lambda values.","code":""},{"path":"/reference/lamNames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate nicely formatted lambda vec — lamNames","text":"character vector formatted lambda value names","code":""},{"path":"/reference/lmm.html","id":null,"dir":"Reference","previous_headings":"","what":"a function to implement a mixed model for structured data without penalization — lmm","title":"a function to implement a mixed model for structured data without penalization — lmm","text":"NB: function simply wrapper lmm_prep -> lmm_fit -> lmm_format","code":""},{"path":"/reference/lmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"a function to implement a mixed model for structured data without penalization — lmm","text":"","code":"lmm(   X,   y,   k = NULL,   K = NULL,   diag_K = NULL,   eta_star = NULL,   eps = 1e-04,   max.iter = 10000,   dfmax = ncol(X) + 1,   warn = TRUE,   init = rep(0, ncol(X)),   returnX = TRUE,   trace = FALSE )"},{"path":"/reference/lmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"a function to implement a mixed model for structured data without penalization — lmm","text":"X Design matrix. MUST high dimensional -- modeling call lm(). high-dimensional data, use plmm() instead. y Continuous outcome vector. k integer specifying number singular values used approximation rotated design matrix. argument passed RSpectra::svds(). Defaults min(n, p) - 1, n p dimensions standardized design matrix. K Similarity matrix used rotate data. (1) known matrix reflects covariance y, (2) estimate (Default \\(\\frac{1}{p}(XX^T)\\)), (3) list created choose_k. diag_K Logical: K diagonal matrix? reflect observations unrelated, can treated unrelated. Defaults FALSE. eta_star Optional argument input specific eta term rather estimate data. K known covariance matrix full rank, 1. eps Convergence threshold. algorithm iterates RMSD change linear predictors coefficient less eps. Default 1e-4. max.iter Maximum number iterations (total across entire path). Default 10000. dfmax Upper bound number nonzero coefficients. Default upper bound. However, large data sets, computational burden may heavy models large number nonzero coefficients. warn Return warning messages failures converge model saturation? Default TRUE. init Initial values coefficients. Default 0 columns X. returnX Return standardized design matrix along fit? default, option turned X 100 MB, turned larger matrices preserve memory. trace set TRUE, inform user progress announcing beginning step modeling process. Default FALSE.","code":""},{"path":"/reference/lmm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"a function to implement a mixed model for structured data without penalization — lmm","text":"list including estimated coefficients original scale, well model fitting details","code":""},{"path":"/reference/lmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"a function to implement a mixed model for structured data without penalization — lmm","text":"","code":"# compare basic LM with LMM (latter accounts for family relationships) fit1 <- lmm(X = pedigree$X, y = pedigree$clinical$y, diag_K = TRUE) fit2 <- lmm(X = pedigree$X, y = pedigree$clinical$y, K = pedigree$K) fit1$beta_vals; fit2$beta_vals #>   (Intercept)          SNP1          SNP2          SNP3          SNP4  #>  0.0003503854  0.1065171689 -0.0268920813  0.0530833917  1.5323230554  #>          SNP5  #>  0.1150140154  #> (Intercept)        SNP1        SNP2        SNP3        SNP4        SNP5  #> -0.04117730  0.07839887  0.03227283  0.01780894  1.53309627  0.16117830"},{"path":"/reference/lmm_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"a function to fit a LMM without penalization to structured data\nNB: this function uses the values returned by lmm_prep()\nThis is an internal function for cv.lmm — lmm_fit","title":"a function to fit a LMM without penalization to structured data\nNB: this function uses the values returned by lmm_prep()\nThis is an internal function for cv.lmm — lmm_fit","text":"function fit LMM without penalization structured data NB: function uses values returned lmm_prep() internal function cv.lmm","code":""},{"path":"/reference/lmm_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"a function to fit a LMM without penalization to structured data\nNB: this function uses the values returned by lmm_prep()\nThis is an internal function for cv.lmm — lmm_fit","text":"","code":"lmm_fit(   prep,   eps = 1e-04,   max.iter = 10000,   warn = TRUE,   init = NULL,   returnX = TRUE )"},{"path":"/reference/lmm_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"a function to fit a LMM without penalization to structured data\nNB: this function uses the values returned by lmm_prep()\nThis is an internal function for cv.lmm — lmm_fit","text":"prep list returned plmm_prep eps Convergence threshold. algorithm iterates RMSD change linear predictors coefficient less eps. Default 1e-4. max.iter Maximum number iterations (total across entire path). Default 10000. warn Return warning messages failures converge model saturation? Default TRUE. init Initial values coefficients. Default 0 columns X. returnX Return standardized design matrix along fit? default, option turned X 100 MB, turned larger matrices preserve memory. penalty penalty applied model. Either \"MCP\" (default), \"SCAD\", \"lasso\". gamma tuning parameter MCP/SCAD penalty (see details). Default 3 MCP 3.7 SCAD. alpha Tuning parameter Mnet estimator controls relative contributions MCP/SCAD penalty ridge, L2 penalty. alpha=1 equivalent MCP/SCAD penalty, alpha=0 equivalent ridge regression. However, alpha=0 supported; alpha may arbitrarily small, exactly 0. lambda.min smallest value lambda, fraction lambda.max. Default .001 number observations larger number covariates .05 otherwise. nlambda Length sequence lambda. Default 100. lambda user-specified sequence lambda values. default, sequence values length nlambda computed, equally spaced log scale. penalty.factor multiplicative factor penalty applied coefficient. supplied, penalty.factor must numeric vector length equal number columns X. purpose penalty.factor apply differential penalization coefficients thought likely others model. particular, penalty.factor can 0, case coefficient always model without shrinkage.","code":""},{"path":"/reference/lmm_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"a function to fit a LMM without penalization to structured data\nNB: this function uses the values returned by lmm_prep()\nThis is an internal function for cv.lmm — lmm_fit","text":"list components: std_X: standardized design matrix rot_X: first partial result data rotation rot_y: second partial result data rotation eta: numeric value representing ratio variances. stdrot_X: re-standardized rotated design matrix. 'fed' lmm_fit(). b: values returned 'beta' argument lmm() object iter: number iterations given lambda value converged: convergence status given lambda value ns: indices non-singular columns ORIGINAL design matrix p: number columns ORIGINAL design matrix","code":""},{"path":"/reference/lmm_format.html","id":null,"dir":"Reference","previous_headings":"","what":"LMM format: a function to format the output of a model constructed with lmm_fit — lmm_format","title":"LMM format: a function to format the output of a model constructed with lmm_fit — lmm_format","text":"LMM format: function format output model constructed lmm_fit","code":""},{"path":"/reference/lmm_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LMM format: a function to format the output of a model constructed with lmm_fit — lmm_format","text":"","code":"lmm_format(fit, dfmax = fit$ncol_X + 1, X)"},{"path":"/reference/lmm_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LMM format: a function to format the output of a model constructed with lmm_fit — lmm_format","text":"fit list parameters describing output model constructed lmm_fit dfmax dfmax Upper bound number nonzero coefficients. Default upper bound. However, large data sets, computational burden may heavy models large number nonzero coefficients. X Design matrix. May include clinical covariates non-SNP data.","code":""},{"path":"/reference/lmm_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LMM format: a function to format the output of a model constructed with lmm_fit — lmm_format","text":"list components: beta_vals: estimated beta values value lambda eta: estimated eta value ns_idx: COME BACK iter: number iterations value lambda (MAYBE take ) converged: convergence status value lambda X: returnX = TRUE size SUX < 100 Mb, original X returned","code":""},{"path":"/reference/lmm_ggmix.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a linear mixed model with lasso regularization — lmm_ggmix","title":"Fit a linear mixed model with lasso regularization — lmm_ggmix","text":"function allows fit linear mixed model via lasso-penalized maximum likelihood.","code":""},{"path":"/reference/lmm_ggmix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a linear mixed model with lasso regularization — lmm_ggmix","text":"","code":"lmm_ggmix(X, y, p1, standardize = FALSE, K = NULL)"},{"path":"/reference/lmm_ggmix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a linear mixed model with lasso regularization — lmm_ggmix","text":"X Design matrix. y Continuous outcome vector. p1 Number causal SNPs. Lambda selected <= p1 variables enter model. standardize standardization performed within glmnet()? Defaults FALSE. K Matrix used compute similarity matrix, K. multi-chromosome analysis may supplied order perform leave-one-chromosome-correction. objective adjust population stratification unobserved confounding without rotating causal SNP effects. Default \\(\\frac{1}{p} XX^T\\)","code":""},{"path":"/reference/lmm_prep.html","id":null,"dir":"Reference","previous_headings":"","what":"a function to prepare data for an unpenalized LMM — lmm_prep","title":"a function to prepare data for an unpenalized LMM — lmm_prep","text":"function prepare data unpenalized LMM","code":""},{"path":"/reference/lmm_prep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"a function to prepare data for an unpenalized LMM — lmm_prep","text":"","code":"lmm_prep(   X,   y,   k = NULL,   K = NULL,   diag_K = NULL,   eta_star = NULL,   returnX = TRUE,   trace = FALSE,   ... )"},{"path":"/reference/lmm_prep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"a function to prepare data for an unpenalized LMM — lmm_prep","text":"X Design matrix. May include clinical covariates non-SNP data. y Continuous outcome vector. k integer specifying number singular values used approximation rotated design matrix. argument passed RSpectra::svds(). Defaults min(n, p) - 1, n p dimensions standardized design matrix. K Similarity matrix used rotate data. either known matrix reflects covariance y, estimate (Default \\(\\frac{1}{p}(XX^T)\\), X standardized). diag_K Logical: K diagonal matrix? reflect observations unrelated, can treated unrelated. Passed lmm(). eta_star Optional argument input specific eta term rather estimate data. K known covariance matrix full rank, 1. returnX Return standardized design matrix along fit? default, option turned X 100 MB, turned larger matrices preserve memory. trace set TRUE, inform user progress announcing beginning step modeling process. Default FALSE. ... used yet","code":""},{"path":"/reference/lmm_prep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"a function to prepare data for an unpenalized LMM — lmm_prep","text":"List components: ncol_X: number columns original design matrix std_X: standardized design matrix y: vector outcomes s: singular values K U: left singular values K (left singular values X). ns: indices nonsingular values std_X snp_names: Formatted column names design matrix","code":""},{"path":"/reference/lmm_untransform.html","id":null,"dir":"Reference","previous_headings":"","what":"Untransform coefficient values back to the original scale for a LMM (no penalization) — lmm_untransform","title":"Untransform coefficient values back to the original scale for a LMM (no penalization) — lmm_untransform","text":"function unwinds steps standardization process obtain coefficient values original scale. called lmm_format().","code":""},{"path":"/reference/lmm_untransform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Untransform coefficient values back to the original scale for a LMM (no penalization) — lmm_untransform","text":"","code":"lmm_untransform(res_b, ns, ncol_X, std_X, SUX, std_SUX)"},{"path":"/reference/lmm_untransform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Untransform coefficient values back to the original scale for a LMM (no penalization) — lmm_untransform","text":"res_b values returned 'coefficient' argument lm.fit() object ns indices non-singular columns ORIGINAL design matrix ncol_X number columns original design matrix (without intercept) std_X standardized design matrix rotation; attributes 'scale', 'center', 'nonsingular' SUX rotated design matrix (intercept) std_SUX standardized design matrix rotation; attribute 'scale'","code":""},{"path":"/reference/logLik_nonnull.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate the negative log-likelihood of a non-null Gaussian plmm model — logLik_nonnull","title":"Evaluate the negative log-likelihood of a non-null Gaussian plmm model — logLik_nonnull","text":"Evaluate negative log-likelihood non-null Gaussian plmm model","code":""},{"path":"/reference/logLik_nonnull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate the negative log-likelihood of a non-null Gaussian plmm model — logLik_nonnull","text":"","code":"logLik_nonnull(fit)"},{"path":"/reference/logLik_nonnull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate the negative log-likelihood of a non-null Gaussian plmm model — logLik_nonnull","text":"fit object class plmm_fit. SUX Rotated design matrix including rotated intercept unpenalized columns, present. SUy Rotated outcome vector. See pp. 16-18 .R.'s thesis details S Eigenvalues similarity matrix used model fitting. eta Estimated $eta$ value object fit.","code":""},{"path":"/reference/log_lik.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate the negative log-likelihood of a null Gaussian plmm model — log_lik","title":"Evaluate the negative log-likelihood of a null Gaussian plmm model — log_lik","text":"function allows evaluate negtive log-likelihood linear mixed model assumption null model order estimate variance parameter, eta.","code":""},{"path":"/reference/log_lik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate the negative log-likelihood of a null Gaussian plmm model — log_lik","text":"","code":"log_lik(eta, rot_y, s)"},{"path":"/reference/log_lik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate the negative log-likelihood of a null Gaussian plmm model — log_lik","text":"eta proportion variance outcome attributable causal SNP effects. words, SNR. Sometimes referred narrow-sense heritability. rot_y continuous outcome, y, rotated eigenvectors similarity matrix, K. s eigenvalues similarity matrix, K.","code":""},{"path":"/reference/log_lik.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate the negative log-likelihood of a null Gaussian plmm model — log_lik","text":"","code":"if (FALSE) { admix$K <- relatedness_mat(admix$X) # create an estimated covariance matrix  ev <- eigen(admix$K) U <- ev$vectors fit <- plmm(X = admix$X, y = admix$y, K = admix$K) (log_lik(eta = fit$eta, rot_y = U%*%admix$y, s = ev$values )) }"},{"path":"/reference/loss.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Loss method for ","title":"Loss method for ","text":"Loss method \"plmm\" class","code":""},{"path":"/reference/loss.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Loss method for ","text":"","code":"loss.plmm(y, yhat)"},{"path":"/reference/loss.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Loss method for ","text":"y Observed response vector yhat Predicted response vector","code":""},{"path":"/reference/loss.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Loss method for ","text":"","code":"fit <- plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X)) yhat <- predict(object = fit, newX = admix$X, type = 'lp', lambda = 0.05) head(loss.plmm(yhat = yhat, y = admix$y)) #>            [,1] #> [1,] 1.29206406 #> [2,] 0.02318985 #> [3,] 0.53478607 #> [4,] 0.13230815 #> [5,] 0.84584198 #> [6,] 0.74175412"},{"path":"/reference/mfdr.html","id":null,"dir":"Reference","previous_headings":"","what":"mfdr: Marginal false discovery rates for PLMMs — mfdr","title":"mfdr: Marginal false discovery rates for PLMMs — mfdr","text":"Based ncvreg::mfdr()","code":""},{"path":"/reference/mfdr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mfdr: Marginal false discovery rates for PLMMs — mfdr","text":"","code":"mfdr(fit)"},{"path":"/reference/mfdr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mfdr: Marginal false discovery rates for PLMMs — mfdr","text":"fit plmm object.","code":""},{"path":"/reference/mfdr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mfdr: Marginal false discovery rates for PLMMs — mfdr","text":"data frame row every value lambda 3 columns: EF: number variables selected given value lambda, averaged permutation fits. S: actual number selected variables non-permuted data. mFDR: estimated marginal false discovery rate (EF/S).","code":""},{"path":"/reference/mfdr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"mfdr: Marginal false discovery rates for PLMMs — mfdr","text":"function estimates marginal false discovery rate (mFDR) penalized regression model. estimate tends accurate settings, slightly conservative predictors highly correlated implemented something like mFDR LMMs yet","code":""},{"path":"/reference/mfdr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"mfdr: Marginal false discovery rates for PLMMs — mfdr","text":"","code":"fit <- plmm(admix$X, admix$y) mfdr(fit) |> head() #>        EF S mFDR #> 0.5997  0 0    0 #> 0.5818  0 0    0 #> 0.5645  0 0    0 #> 0.5476  0 0    0 #> 0.5313  0 0    0 #> 0.5155  1 1    1"},{"path":"/reference/mfdr_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for mFDR — mfdr_plot","title":"Plot method for mFDR — mfdr_plot","text":"Plot method mFDR","code":""},{"path":"/reference/mfdr_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for mFDR — mfdr_plot","text":"","code":"mfdr_plot(mfdr, logscale = TRUE, ...)"},{"path":"/reference/mfdr_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for mFDR — mfdr_plot","text":"mfdr data frame returned mfdr() logscale Logical: lambda values plotted log scale? Defaults TRUE. ... arguments passed plot()","code":""},{"path":"/reference/mfdr_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot method for mFDR — mfdr_plot","text":"","code":"cv <- cv.plmm(admix$X, admix$y) fit <- cv$fit mfdr_plot(mfdr(fit), type = \"l\")"},{"path":"/reference/pedigree.html","id":null,"dir":"Reference","previous_headings":"","what":"Pedigree: mock genotype data from a family-based design. — pedigree","title":"Pedigree: mock genotype data from a family-based design. — pedigree","text":"mock dataset containing genotypes, family relationships, continuous phenotype dataset inspired one T. Peter's collaborative projects involving analysis congenital disorders family-based data. outcome indicated severity phenotype, higher values -> severe.","code":""},{"path":"/reference/pedigree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pedigree: mock genotype data from a family-based design. — pedigree","text":"","code":"pedigree"},{"path":[]},{"path":"/reference/pedigree.html","id":"pedigree","dir":"Reference","previous_headings":"","what":"pedigree","title":"Pedigree: mock genotype data from a family-based design. — pedigree","text":"list 3 components: X: Design matrix representing 23 family members 5 genes K: Matrix representing family members' relationships expected proportions genetic overlap. Values 0.5 represent parent-child sibling relationships; see data-raw/pedigree.R details. Note: correlation matrix. Use cov2cor() similar function obtain correlations. clinical: data frame 23 observations 3 variables: sample.id integer indicating sample.id (IID PLINK .fam file) sex biological sex participant (just like PLINK, 2 = female & 1 = male) y numeric value corresponding phenotype severity","code":""},{"path":"/reference/plink_example.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to help with accessing example PLINK files — plink_example","title":"A function to help with accessing example PLINK files — plink_example","text":"function help accessing example PLINK files","code":""},{"path":"/reference/plink_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to help with accessing example PLINK files — plink_example","text":"","code":"plink_example(path, parent = FALSE)"},{"path":"/reference/plink_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to help with accessing example PLINK files — plink_example","text":"path Argument (string) specifying path (filename) external data file extdata/ parent path=TRUE user wants name parent directory file located, set parent=TRUE. Defaults FALSE.","code":""},{"path":"/reference/plink_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to help with accessing example PLINK files — plink_example","text":"path=NULL, character vector file names returned. path given, character string full file path","code":""},{"path":"/reference/plmm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"plmm: Fit nonconvex-penalized linear mixed models to account for the presence of unobserved confounding effects — plmm-package","title":"plmm: Fit nonconvex-penalized linear mixed models to account for the presence of unobserved confounding effects — plmm-package","text":"Fit penalized linear mixed model corrects unobserved confounding factors. plmm infers corrects presence unobserved confounding effects population stratification environmental heterogeneity. fits linear model via lasso penalized maximum likelihood. Originally designed multivariate analysis SNP data, plmm eliminates need LD pruning subpopulation-specific analyses. Functions appropriate processing PLINK files also supplied.","code":""},{"path":"/reference/plmm-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plmm: Fit nonconvex-penalized linear mixed models to account for the presence of unobserved confounding effects — plmm-package","text":"Maintainer: Tabitha K. Peter tabitha-peter@uiowa.edu Authors: Anna C. Reisetter anna-reisetter@uiowa.edu (ORCID) Patrick J. Breheny (ORCID) Yujiing Lu","code":""},{"path":"/reference/plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a linear mixed model with non-convex regularization — plmm","title":"Fit a linear mixed model with non-convex regularization — plmm","text":"function allows fit linear mixed model via non-convex penalized maximum likelihood. NB: function simply wrapper plmm_prep -> plmm_fit -> plmm_format","code":""},{"path":"/reference/plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a linear mixed model with non-convex regularization — plmm","text":"","code":"plmm(   X,   y,   k = NULL,   K = NULL,   diag_K = NULL,   eta_star = NULL,   penalty = c(\"MCP\", \"SCAD\", \"lasso\"),   gamma,   alpha = 1,   lambda.min,   nlambda = 100,   lambda,   eps = 1e-04,   max.iter = 10000,   convex = TRUE,   dfmax = ncol(X) + 1,   warn = TRUE,   penalty.factor = rep(1, ncol(X)),   init = rep(0, ncol(X)),   trace = FALSE )"},{"path":"/reference/plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a linear mixed model with non-convex regularization — plmm","text":"X Design matrix object string file path design matrix. string, string passed get_data(). Note: X may include clinical covariates non-SNP data, missing values allowed. y Continuous outcome vector. Logistic regression modeling still development. k integer specifying number singular values used approximation rotated design matrix. argument passed RSpectra::svds(). Defaults min(n, p) - 1, n p dimensions standardized design matrix. K Similarity matrix used rotate data. either (1) known matrix reflects covariance y, (2) estimate (Default \\(\\frac{1}{p}(XX^T)\\)), (3) list components 'd' 'u', returned choose_k(). diag_K Logical: K diagonal matrix? reflect observations unrelated, can treated unrelated. Defaults FALSE. Note: plmm() check see matrix diagonal. want use diagonal K matrix, must set diag_K = TRUE. eta_star Optional argument input specific eta term rather estimate data. K known covariance matrix full rank, 1. penalty penalty applied model. Either \"MCP\" (default), \"SCAD\", \"lasso\". gamma tuning parameter MCP/SCAD penalty (see details). Default 3 MCP 3.7 Spenncath. alpha Tuning parameter Mnet estimator controls relative contributions MCP/Spenncath penalty ridge, L2 penalty. alpha=1 equivalent MCP/Spenncath penalty, alpha=0 equivalent ridge regression. However, alpha=0 supported; alpha may arbitrarily small, exactly 0. lambda.min smallest value lambda, fraction lambda.max. Default .001 number observations larger number covariates .05 otherwise. nlambda Length sequence lambda. Default 100. lambda user-specified sequence lambda values. default, sequence values length nlambda computed, equally spaced log scale. eps Convergence threshold. algorithm iterates RMSD change linear predictors coefficient less eps. Default 1e-4. max.iter Maximum number iterations (total across entire path). Default 10000. convex Calculate index objective function ceases locally convex? Default TRUE. dfmax Upper bound number nonzero coefficients. Default upper bound. However, large data sets, computational burden may heavy models large number nonzero coefficients. warn Return warning messages failures converge model saturation? Default TRUE. penalty.factor multiplicative factor penalty applied coefficient. supplied, penalty.factor must numeric vector length equal number columns X. purpose penalty.factor apply differential penalization coefficients thought likely others model. particular, penalty.factor can 0, case coefficient always model without shrinkage. init Initial values coefficients. Default 0 columns X. trace set TRUE, inform user progress announcing beginning step modeling process. Default FALSE.","code":""},{"path":"/reference/plmm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a linear mixed model with non-convex regularization — plmm","text":"list including estimated coefficients original scale, well model fitting details","code":""},{"path":"/reference/plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a linear mixed model with non-convex regularization — plmm","text":"","code":"# using admix data  fit_admix1 <- plmm(X = admix$X, y = admix$y) s1 <- summary(fit_admix1, idx = 99) print(s1) #> MCP-penalized regression model with n=, p=101 at lambda=0.0309 #> ------------------------------------------------- #> The model converged  #> ------------------------------------------------- #> # of non-zero coefficients:  80  #> -------------------------------------------------  # using admix data and k = 50  fit_admix2 <- plmm(X = admix$X, y = admix$y, k = 50) s2 <- summary(fit_admix2, idx = 99) print(s2) #> MCP-penalized regression model with n=, p=101 at lambda=0.0385 #> ------------------------------------------------- #> The model converged  #> ------------------------------------------------- #> # of non-zero coefficients:  26  #> -------------------------------------------------  # an example with p > n: fit_admix3 <- plmm(X = admix$X[1:50, ], y = admix$y[1:50])  # now use PLINK data files if (FALSE) {  penncath_mid <- process_plink(prefix = \"penncath_mid\", dataDir = plink_example(path=\"penncath_mid.fam\", parent=T)) penncath_clinical <- read.csv(plink_example(path=\"penncath_clinical.csv\")) # for the sake of illustration, I use a simple mean imputation for the outcome  penncath_clinical$hdl_impute <- ifelse(is.na(penncath_clinical$hdl), mean(penncath_clinical$hdl, na.rm = T), penncath_clinical$hdl)  # fit with no 'k' specified fit_plink1 <- plmm(X = penncath_mid$X, y = penncath_clinical$hdl_impute, trace = TRUE) summary(fit_plink1, idx = 5) # Runs in ~219 seconds (3.65 mins) on my 2015 MacBook Pro  # fit with 'k = 5' specified (so using RSpectra::svds()) fit_plink2 <- plmm(X = penncath_mid$X, y = penncath_clinical$hdl_impute, k = 5, trace = TRUE) # Runs in ~44 seconds on my 2015 MacBook Pro summary(fit_plink2, idx = 5);summary(fit_plink2, idx = 95) }"},{"path":"/reference/plmm_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"PLMM fit: a function that fits a PLMM using the values returned by plmm_prep()\nThis is an internal function for cv.plmm — plmm_fit","title":"PLMM fit: a function that fits a PLMM using the values returned by plmm_prep()\nThis is an internal function for cv.plmm — plmm_fit","text":"PLMM fit: function fits PLMM using values returned plmm_prep() internal function cv.plmm","code":""},{"path":"/reference/plmm_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PLMM fit: a function that fits a PLMM using the values returned by plmm_prep()\nThis is an internal function for cv.plmm — plmm_fit","text":"","code":"plmm_fit(   prep,   penalty = \"MCP\",   gamma,   alpha = 1,   lambda.min,   nlambda = 100,   lambda,   eps = 1e-04,   max.iter = 10000,   convex = TRUE,   dfmax = prep$p + 1,   init = NULL,   warn = TRUE,   returnX = TRUE )"},{"path":"/reference/plmm_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PLMM fit: a function that fits a PLMM using the values returned by plmm_prep()\nThis is an internal function for cv.plmm — plmm_fit","text":"prep list returned plmm_prep penalty penalty applied model. Either \"MCP\" (default), \"SCAD\", \"lasso\". gamma tuning parameter MCP/SCAD penalty (see details). Default 3 MCP 3.7 SCAD. alpha Tuning parameter Mnet estimator controls relative contributions MCP/SCAD penalty ridge, L2 penalty. alpha=1 equivalent MCP/SCAD penalty, alpha=0 equivalent ridge regression. However, alpha=0 supported; alpha may arbitrarily small, exactly 0. lambda.min smallest value lambda, fraction lambda.max. Default .001 number observations larger number covariates .05 otherwise. nlambda Length sequence lambda. Default 100. lambda user-specified sequence lambda values. default, sequence values length nlambda computed, equally spaced log scale. eps Convergence threshold. algorithm iterates RMSD change linear predictors coefficient less eps. Default 1e-4. max.iter Maximum number iterations (total across entire path). Default 10000. convex convex Calculate index objective function ceases locally convex? Default TRUE. dfmax (future idea; yet incorporated) Upper bound number nonzero coefficients. Default upper bound. However, large data sets, computational burden may heavy models large number nonzero coefficients. init Initial values coefficients. Default 0 columns X. warn Return warning messages failures converge model saturation? Default TRUE. returnX Return standardized design matrix along fit? default, option turned X 100 MB, turned larger matrices preserve memory.","code":""},{"path":"/reference/plmm_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PLMM fit: a function that fits a PLMM using the values returned by plmm_prep()\nThis is an internal function for cv.plmm — plmm_fit","text":"list components: std_X: standardized design matrix rot_X: first partial result data rotation rot_y: second partial result data rotation eta: numeric value representing ratio variances. std_rot_X: re-standardized rotated design matrix. 'fed' plmm_fit(). b: values returned 'beta' argument ncvfit() object lambda: sequence lambda values used model fitting iter: number iterations given lambda value converged: convergence status given lambda value penalty: type penalty used model fitting penalty.factor: multiplicative factor penalty applied coefficient. supplied, penalty.factor must numeric vector length equal number columns X. purpose penalty.factor apply differential penalization coefficients thought likely others model. particular, penalty.factor can 0, case coefficient always model without shrinkage. ns: indices non-singular columns ORIGINAL design matrix ncol_X: number columns ORIGINAL design matrix","code":""},{"path":"/reference/plmm_format.html","id":null,"dir":"Reference","previous_headings":"","what":"PLMM format: a function to format the output of a model constructed with plmm_fit — plmm_format","title":"PLMM format: a function to format the output of a model constructed with plmm_fit — plmm_format","text":"PLMM format: function format output model constructed plmm_fit","code":""},{"path":"/reference/plmm_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PLMM format: a function to format the output of a model constructed with plmm_fit — plmm_format","text":"","code":"plmm_format(fit, X)"},{"path":"/reference/plmm_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PLMM format: a function to format the output of a model constructed with plmm_fit — plmm_format","text":"fit list parameters describing output model constructed plmm_fit X Design matrix. May include clinical covariates non-SNP data.","code":""},{"path":"/reference/plmm_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PLMM format: a function to format the output of a model constructed with plmm_fit — plmm_format","text":"list components: beta_vals: estimated beta values value lambda eta: estimated eta value lambda: sequence lambda values used model fitting penalty: string indicating type penalty used fit model ns_idx: COME BACK iter: number iterations value lambda (MAYBE take ) converged: convergence status value lambda","code":""},{"path":"/reference/plmm_prep.html","id":null,"dir":"Reference","previous_headings":"","what":"PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model\nThis is an internal function for cv.plmm — plmm_prep","title":"PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model\nThis is an internal function for cv.plmm — plmm_prep","text":"PLMM prep: function run checks, SVD, rotation prior fitting PLMM model internal function cv.plmm","code":""},{"path":"/reference/plmm_prep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model\nThis is an internal function for cv.plmm — plmm_prep","text":"","code":"plmm_prep(   X,   y,   k = NULL,   K = NULL,   diag_K = NULL,   eta_star = NULL,   penalty.factor = rep(1, ncol(X)),   trace = NULL,   ... )"},{"path":"/reference/plmm_prep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model\nThis is an internal function for cv.plmm — plmm_prep","text":"X Design matrix. May include clinical covariates non-SNP data. y Continuous outcome vector. k integer specifying number singular values used approximation rotated design matrix. argument passed RSpectra::svds(). Defaults min(n, p) - 1, n p dimensions standardized design matrix. K Similarity matrix used rotate data. either known matrix reflects covariance y, estimate (Default \\(\\frac{1}{p}(XX^T)\\), X standardized). can also list, components d u (returned choose_k) diag_K Logical: K diagonal matrix? reflect observations unrelated, can treated unrelated. Passed plmm(). eta_star Optional argument input specific eta term rather estimate data. K known covariance matrix full rank, 1. penalty.factor multiplicative factor penalty applied coefficient. supplied, penalty.factor must numeric vector length equal number columns X. purpose penalty.factor apply differential penalization coefficients thought likely others model. particular, penalty.factor can 0, case coefficient always model without shrinkage. trace set TRUE, inform user progress announcing beginning step modeling process. Default FALSE. ... used yet","code":""},{"path":"/reference/plmm_prep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model\nThis is an internal function for cv.plmm — plmm_prep","text":"List components: ncol_X: number columns original design matrix std_X: standardized design matrix y: vector outcomes S: singular values K U: left singular values K (left singular values X). ns: indices nonsingular values std_X penalty.factor: penalty factors penalized non-singular values snp_names: Formatted column names design matrix","code":""},{"path":"/reference/plmm_prep.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PLMM prep: a function to run checks, SVD, and rotation prior to fitting a PLMM model\nThis is an internal function for cv.plmm — plmm_prep","text":"","code":"if (FALSE) { # this is an internal function; to call this, you would need to use the triple  # colon, eg plmm:::plmm_prep() prep1 <- plmm_prep(X = admix$X, y = admix$y, trace = TRUE) prep2 <- plmm_prep(X = admix$X, y = admix$y, diag_K = TRUE, trace = TRUE) }"},{"path":"/reference/plot.cv.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for cv.plmm class — plot.cv.plmm","title":"Plot method for cv.plmm class — plot.cv.plmm","text":"Plot method cv.plmm class","code":""},{"path":"/reference/plot.cv.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for cv.plmm class — plot.cv.plmm","text":"","code":"# S3 method for cv.plmm plot(   x,   log.l = TRUE,   type = c(\"cve\", \"rsq\", \"scale\", \"snr\", \"all\"),   selected = TRUE,   vertical.line = TRUE,   col = \"red\",   ... )"},{"path":"/reference/plot.cv.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for cv.plmm class — plot.cv.plmm","text":"x object class cv.plmm log.l Logical indicate plot returned natural log scale. Defaults log.l = FALSE. type Type plot return. Defaults \"cve.\" selected Logical indicate variables plotted. Defaults TRUE. vertical.line Logical indicate whether vertical line plotted minimum/maximum value. Defaults TRUE. col Color vertical line, plotted. Defaults \"red.\" ... Additional arguments.","code":""},{"path":"/reference/plot.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for plmm class — plot.plmm","title":"Plot method for plmm class — plot.plmm","text":"Plot method plmm class","code":""},{"path":"/reference/plot.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for plmm class — plot.plmm","text":"","code":"# S3 method for plmm plot(x, alpha = 1, log.l = FALSE, shade = TRUE, col, ...)"},{"path":"/reference/plot.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for plmm class — plot.plmm","text":"x object class plmm alpha Tuning parameter Mnet estimator controls relative contributions MCP/SCAD penalty ridge, L2 penalty. alpha=1 equivalent MCP/SCAD penalty, alpha=0 equivalent ridge regression. However, alpha=0 supported; alpha may arbitrarily small, exactly 0. log.l Logical indicate plot returned natural log scale. Defaults log.l = FALSE. shade Logical indicate whether local nonconvex region shaded. Defaults TRUE. col Vector colors coefficient lines. ... Additional arguments.","code":""},{"path":"/reference/plot.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot method for plmm class — plot.plmm","text":"","code":"fit <- plmm(admix$X[,1:10], admix$y, nlambda = 10) # for the sake of illustration, I consider only 10 SNPs in the plot  plot(fit)  plot(fit, log.l = TRUE)"},{"path":"/reference/predict.list.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for a list used in cross-validation (within cvf) — predict.list","title":"Predict method for a list used in cross-validation (within cvf) — predict.list","text":"Predict method list used cross-validation (within cvf)","code":""},{"path":"/reference/predict.list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for a list used in cross-validation (within cvf) — predict.list","text":"","code":"# S3 method for list predict(   fit,   oldX,   newX,   type = c(\"lp\", \"blup\"),   idx = 1:length(fit$lambda),   V11 = NULL,   V21 = NULL,   ... )"},{"path":"/reference/predict.list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for a list used in cross-validation (within cvf) — predict.list","text":"fit list components returned plmm_fit. oldX standardized design matrix training data, pre-rotation. newX design matrix used computing predicted values (.e, test data). type character argument indicating type prediction returned. Options \"lp,\" \"coefficients,\" \"vars,\" \"nvars,\" \"blup.\" See details. idx Vector indices penalty parameter lambda predictions required. default, indices returned. V11 Variance-covariance matrix training data. Extracted estimated_V generated using observations. Required type == 'blup'. V21 Covariance matrix training testing data. Extracted estimated_V generated using observations. Required type == 'blup'. ... Additional optional arguments","code":""},{"path":"/reference/predict.list.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict method for a list used in cross-validation (within cvf) — predict.list","text":"Define beta-hat coefficients estimated value lambda minimizes cross-validation error (CVE). options type follows: 'lp' (default): uses linear predictor (.e., product new data estimated coefficients) predict new values outcome. Note approach incorporate correlation structure data. 'blup' (acronym Best Linear Unbiased Predictor): adds 'lp' value represents estimated random effect. addition way incorporating estimated correlation structure data prediction outcome.","code":""},{"path":"/reference/predict.lmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for lmm class — predict.lmm","title":"Predict method for lmm class — predict.lmm","text":"Predict method lmm class","code":""},{"path":"/reference/predict.lmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for lmm class — predict.lmm","text":"","code":"# S3 method for lmm predict(object, newX, type = c(\"lp\", \"coefficients\", \"blup\"), X, y, ...)"},{"path":"/reference/predict.lmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for lmm class — predict.lmm","text":"object object class plmm. newX Design matrix used computing predicted values requested. type character argument indicating type prediction returned. Options \"lp,\" \"coefficients,\" \"vars,\" \"nvars,\" \"blup.\" See details. X Optional argument. Original design matrix (including intercept column) object. Required type == 'blup' object large returned plmm object. y Optional argument. Original continuous outcome vector object. Required type == 'blup'. ... Additional optional arguments","code":""},{"path":"/reference/predict.lmm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict method for lmm class — predict.lmm","text":"Define beta-hat coefficients estimated value lambda minimizes cross-validation error (CVE). options type follows: 'lp' (default): uses product newX beta-hat predict new values outcome. incorporate correlation structure data. stats folks , simply linear predictor. 'blup' (acronym Best Linear Unbiased Predictor): adds 'response' value represents esetimated random effect. addition way incorporating estimated correlation structure data prediction outcome. 'coefficients': returns estimated beta-hat","code":""},{"path":"/reference/predict.lmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict method for lmm class — predict.lmm","text":"","code":"if (FALSE) { # fit a model  fit <- lmm(X = pedigree$X, y = pedigree$clinical$y) predict.lmm(fit, type = \"coefficients\") predict.lmm(fit, type = \"lp\", newX = pedigree$X) predict.lmm(fit, type = \"blup\", X = pedigree$X, newX = pedigree$X, y = pedigree$clinical$y) }"},{"path":"/reference/predict.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for plmm class — predict.plmm","title":"Predict method for plmm class — predict.plmm","text":"Predict method plmm class","code":""},{"path":"/reference/predict.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for plmm class — predict.plmm","text":"","code":"# S3 method for plmm predict(   object,   newX,   type = c(\"lp\", \"coefficients\", \"vars\", \"nvars\", \"blup\"),   lambda,   idx = 1:length(object$lambda),   X,   y,   K = NULL,   ... )"},{"path":"/reference/predict.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for plmm class — predict.plmm","text":"object object class plmm. newX Design matrix used computing predicted values requested. type character argument indicating type prediction returned. Options \"lp,\" \"coefficients,\" \"vars,\" \"nvars,\" \"blup.\" See details. lambda numeric vector regularization parameter lambda values predictions requested. idx Vector indices penalty parameter lambda predictions required. default, indices returned. X Optional argument. Original design matrix (including intercept column) object. Required type == 'blup' object large returned plmm object. y Optional argument. Original continuous outcome vector object. Required type == 'blup'. K optional list matrix returned choose_K(). ... Additional optional arguments","code":""},{"path":"/reference/predict.plmm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict method for plmm class — predict.plmm","text":"Define beta-hat coefficients estimated value lambda minimizes cross-validation error (CVE). options type follows: 'response' (default): uses product newX beta-hat predict new values outcome. incorporate correlation structure data. stats folks , simply linear predictor. 'blup' (acronym Best Linear Unbiased Predictor): adds 'response' value represents esetimated random effect. addition way incorporating estimated correlation structure data prediction outcome. 'coefficients': returns estimated beta-hat 'vars': returns indicies variables (e.g., SNPs) nonzero coefficients value lambda. EXCLUDES intercept. 'nvars': returns number variables (e.g., SNPs) nonzero coefficients value lambda. EXCLUDES intercept.","code":""},{"path":"/reference/predict.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict method for plmm class — predict.plmm","text":"","code":"if (FALSE) { # fit a model  fit <- plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X))  # simulate new data  newX <- sim_ps_x(n = nrow(admix$X), nJ = 4, p = ncol(admix$X),  structureX = \"independent\", inbr = \"heterogeneous\", standardizeX = FALSE)    # make predictions for all lambda values   pred1 <- predict(object = fit, newX = newX, type = \"lp\")    # make predictions for a select number of lambda values   pred2 <- predict(object = fit, newX = newX, type = \"lp\", idx=98)  }"},{"path":"/reference/print.summary.cv.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary.cv.plmm objects — print.summary.cv.plmm","title":"Print method for summary.cv.plmm objects — print.summary.cv.plmm","text":"Print method summary.cv.plmm objects","code":""},{"path":"/reference/print.summary.cv.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary.cv.plmm objects — print.summary.cv.plmm","text":"","code":"# S3 method for summary.cv.plmm print(x, digits, ...)"},{"path":"/reference/print.summary.cv.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary.cv.plmm objects — print.summary.cv.plmm","text":"x object class summary.cv.plmm digits number digits use formatting output ... used","code":""},{"path":"/reference/print.summary.cv.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print method for summary.cv.plmm objects — print.summary.cv.plmm","text":"","code":"cv_fit <- cv.plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X)) print(summary(cv_fit)) #> MCP-penalized model with n=197 and p=100 #> At minimum cross-validation error (lambda=0.1210): #> ------------------------------------------------- #>   Nonzero coefficients: 25 #>   Cross-validation error (deviance): 2.05 #>   Scale estimate (sigma): 1.430"},{"path":"/reference/print.summary.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to print the summary of a plmm model — print.summary.plmm","title":"A function to print the summary of a plmm model — print.summary.plmm","text":"function print summary plmm model","code":""},{"path":"/reference/print.summary.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to print the summary of a plmm model — print.summary.plmm","text":"","code":"# S3 method for summary.plmm print(x, ...)"},{"path":"/reference/print.summary.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to print the summary of a plmm model — print.summary.plmm","text":"x summary.plmm object ... used","code":""},{"path":"/reference/print.summary.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A function to print the summary of a plmm model — print.summary.plmm","text":"","code":"fit <- plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X)) fit2 <- plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X), penalty = \"SCAD\") s1 <- summary(fit, idx = 97) s2 <- summary(fit, lambda = fit$lambda[97]) s3 <- summary(fit2, idx = 25) print(s1) #> MCP-penalized regression model with n=, p=101 at lambda=0.00121 #> ------------------------------------------------- #> The model converged  #> ------------------------------------------------- #> # of non-zero coefficients:  98  #> ------------------------------------------------- print(s2) #> MCP-penalized regression model with n=, p=101 at lambda=0.00121 #> ------------------------------------------------- #> The model converged  #> ------------------------------------------------- #> # of non-zero coefficients:  98  #> ------------------------------------------------- print(s3) #> SCAD-penalized regression model with n=, p=101 at lambda=0.18395 #> ------------------------------------------------- #> The model converged  #> ------------------------------------------------- #> # of non-zero coefficients:  20  #> -------------------------------------------------"},{"path":"/reference/process_plink.html","id":null,"dir":"Reference","previous_headings":"","what":"Preprocess PLINK files using the bigsnpr package — process_plink","title":"Preprocess PLINK files using the bigsnpr package — process_plink","text":"Preprocess PLINK files using bigsnpr package","code":""},{"path":"/reference/process_plink.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preprocess PLINK files using the bigsnpr package — process_plink","text":"","code":"process_plink(   data_dir,   prefix,   impute = TRUE,   impute_method = \"mode\",   quiet = FALSE,   gz = FALSE,   outfile,   ... )"},{"path":"/reference/process_plink.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Preprocess PLINK files using the bigsnpr package — process_plink","text":"data_dir path bed/bim/fam data files prefix prefix (character string) bed/fam data files impute Logical: data imputed? Default TRUE. impute_method 'impute' = TRUE, argument specify kind imputation desired. Options : mode (default): Imputes frequent call. See bigsnpr::snp_fastImputeSimple() details. random: Imputes sampling according allele frequencies. mean0: Imputes rounded mean. mean2: Imputes mean rounded 2 decimal places. xgboost: Imputes using algorithm based local XGBoost models. See bigsnpr::snp_fastImpute() details. Note: can take several minutes, even relatively small data set. quiet Logical: messages printed console? Defaults TRUE gz Logical: bed/bim/fam files g-zipped? Defaults FALSE. NOTE: TRUE, process_plink unzip zipped files. outfile Optional: name (character string) prefix logfile written. Defaults 'process_plink', .e. get 'process_plink.log' outfile. ... Optional: additional arguments bigsnpr::snp_fastImpute() (relevant impute_method = \"xgboost\")","code":""},{"path":"/reference/process_plink.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Preprocess PLINK files using the bigsnpr package — process_plink","text":"","code":"if (FALSE) { process_plink(data_dir = \"../temp_files\",  prefix = \"penncath_lite\",   impute = T,    quiet = F) }"},{"path":"/reference/relatedness_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a relatedness matrix — relatedness_mat","title":"Calculate a relatedness matrix — relatedness_mat","text":"function allows generate n n genetic relatedness matrix. numeric matrix supplied, RRM (Hayes, 2009) used computed XX'/p, X standardized.","code":""},{"path":"/reference/relatedness_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a relatedness matrix — relatedness_mat","text":"","code":"relatedness_mat(X)"},{"path":"/reference/relatedness_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a relatedness matrix — relatedness_mat","text":"X numeric matrix genotypes (fully-imputed data)","code":""},{"path":"/reference/relatedness_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a relatedness matrix — relatedness_mat","text":"","code":"RRM <- relatedness_mat(X = admix$X)"},{"path":"/reference/residuals.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract residuals from a PLMM fit — residuals.plmm","title":"Extract residuals from a PLMM fit — residuals.plmm","text":"Currently, deviance residuals supported.","code":""},{"path":"/reference/residuals.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract residuals from a PLMM fit — residuals.plmm","text":"","code":"# S3 method for plmm residuals(   object,   lambda,   which = 1:length(object$lambda),   drop = TRUE,   unrotate = FALSE,   ... )"},{"path":"/reference/residuals.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract residuals from a PLMM fit — residuals.plmm","text":"object Object class plmm. lambda Values regularization parameter residuals requested (numeric vector). values lambda sequence fitted models, linear interpolation used. Index penalty parameter residuals requested (default = indices). lambda specified, take precedence . drop default, single value lambda supplied, vector residuals returned (logical; default=TRUE). Set drop=FALSE wish function always return matrix (see drop()). unrotate Logical: residuals 'unrotated', .e. transformed back original scale? ... used.","code":""},{"path":"/reference/residuals.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract residuals from a PLMM fit — residuals.plmm","text":"","code":"if (FALSE) { fit <- plmm(admix$X, admix$y) residuals.plmm(fit)[1:5, 1:5] head(residuals.plmm(fit, which = 50)) }"},{"path":"/reference/scale_varp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate scale by the population standard deviation, without centering — scale_varp","title":"Calculate scale by the population standard deviation, without centering — scale_varp","text":"function allows scale vectors matrix population standard deviation without centering; assume sample population.","code":""},{"path":"/reference/scale_varp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate scale by the population standard deviation, without centering — scale_varp","text":"","code":"scale_varp(X)"},{"path":"/reference/scale_varp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate scale by the population standard deviation, without centering — scale_varp","text":"X numeric matrix","code":""},{"path":"/reference/scale_varp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate scale by the population standard deviation, without centering — scale_varp","text":"","code":"if (FALSE) { M <- matrix(rnorm(25), 5, 5) head(M) M_scaled <- scale_varp(M) head(M_scaled)  X_scaled <- scale_varp(admix$X) admix$X[1:5, 1:7]; X_scaled[1:5, 1:7] }"},{"path":"/reference/setup_lambda.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute sequence of lambda values — setup_lambda","title":"Compute sequence of lambda values — setup_lambda","text":"function allows compute sequence lambda values plmm models.","code":""},{"path":"/reference/setup_lambda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute sequence of lambda values — setup_lambda","text":"","code":"setup_lambda(   X,   y,   alpha,   lambda.min,   nlambda,   penalty.factor,   intercept = TRUE )"},{"path":"/reference/setup_lambda.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute sequence of lambda values — setup_lambda","text":"X Rotated standardized design matrix includes intercept column present. May include clinical covariates non-SNP data. y Continuous outcome vector. alpha Tuning parameter Mnet estimator controls relative contributions MCP/SCAD penalty ridge, L2 penalty. alpha=1 equivalent MCP/SCAD penalty, alpha=0 equivalent ridge regression. However, alpha=0 supported; alpha may arbitrarily small, exactly 0. lambda.min smallest value lambda, fraction lambda.max. Default .001 number observations larger number covariates .05 otherwise. value lambda.min = 0 supported. nlambda desired number lambda values sequence generated. penalty.factor multiplicative factor penalty applied coefficient. supplied, penalty.factor must numeric vector length equal number columns X. purpose penalty.factor apply differential penalization coefficients thought likely others model. particular, penalty.factor can 0, case coefficient always model without shrinkage. intercept Logical: X contain intercept column? Defaults TRUE.","code":""},{"path":"/reference/setup_lambda.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute sequence of lambda values — setup_lambda","text":"","code":"if (FALSE) { RRM <- relatedness_mat(X = scale(admix$X)) fit <- plmm_lasso(X = admix$X, y = admix$y, K = RRM, p1 = 10) (setup_lambda(admix$X, admix$y, alpha = 0.1, nlambda = 10,  penalty.factor = fit$penalty.factor)) # use default lambda.min }"},{"path":"/reference/summary.cv.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"A summary function for cv.plmm objects — summary.cv.plmm","title":"A summary function for cv.plmm objects — summary.cv.plmm","text":"summary function cv.plmm objects","code":""},{"path":"/reference/summary.cv.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A summary function for cv.plmm objects — summary.cv.plmm","text":"","code":"# S3 method for cv.plmm summary(object, lambda = \"min\", ...)"},{"path":"/reference/summary.cv.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A summary function for cv.plmm objects — summary.cv.plmm","text":"object cv.plmm object lambda regularization parameter value inference reported. Can choose numeric value, 'min', '1se'. Defaults 'min.' ... used","code":""},{"path":"/reference/summary.cv.plmm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A summary function for cv.plmm objects — summary.cv.plmm","text":"return value object S3 class summary.cv.plmm. class print method contains following list elements: lambda.min: lambda value minimum cross validation error lambda.1se: maximum lambda value within 1 standard error minimum cross validation error nvars: number non-zero coefficients selected lambda value cve: cross validation error folds min: minimum cross validation error fit: plmm fit used cross validation bias: mean bias cross validation loss: loss (fold?) TODO: double-check penalty: penalty applied fitted model","code":""},{"path":"/reference/summary.cv.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A summary function for cv.plmm objects — summary.cv.plmm","text":"","code":"cv_fit <- cv.plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X)) summary(cv_fit) #> MCP-penalized model with n=197 and p=100 #> At minimum cross-validation error (lambda=0.1210): #> ------------------------------------------------- #>   Nonzero coefficients: 25 #>   Cross-validation error (deviance): 1.99 #>   Scale estimate (sigma): 1.409"},{"path":"/reference/summary.plmm.html","id":null,"dir":"Reference","previous_headings":"","what":"A summary method for the plmm objects — summary.plmm","title":"A summary method for the plmm objects — summary.plmm","text":"summary method plmm objects","code":""},{"path":"/reference/summary.plmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A summary method for the plmm objects — summary.plmm","text":"","code":"# S3 method for plmm summary(object, lambda, idx, eps = 1e-05, ...)"},{"path":"/reference/summary.plmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A summary method for the plmm objects — summary.plmm","text":"object object class plmm lambda regularization parameter value inference reported. idx Alternatively, lambda may specified index; idx=10 means: report inference 10th value lambda along regularization path. lambda idx specified, lambda takes precedence. eps lambda given, eps tolerance difference given lambda value lambda value object. Defaults 0.0001 (1e-5) ... used","code":""},{"path":"/reference/summary.plmm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A summary method for the plmm objects — summary.plmm","text":"return value object S3 class summary.plmm. class print method contains following list elements: penalty: penalty used plmm (e.g. SCAD, MCP, lasso) n: Number instances/observations p: Number regression coefficients (including intercept) converged: Logical indicator whether model converged lambda: lambda value inference reported lambda_char: formatted character string indicating lambda value nvars: number nonzero coefficients (, including intercept) value lambda nonzero: column names indicating nonzero coefficients model specified value lambda constant_features: character vector names columns design matrix whose values constant whole sample (e.g., monomorphic SNPs genetics context)","code":""},{"path":"/reference/summary.plmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A summary method for the plmm objects — summary.plmm","text":"","code":"fit <- cv.plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X)) summary(fit$fit, idx = 97) #> MCP-penalized regression model with n=, p=101 at lambda=0.00121 #> ------------------------------------------------- #> The model converged  #> ------------------------------------------------- #> # of non-zero coefficients:  98  #> ------------------------------------------------- summary(fit, lambda = fit$lambda.min) #> MCP-penalized model with n=197 and p=100 #> At minimum cross-validation error (lambda=0.1129): #> ------------------------------------------------- #>   Nonzero coefficients: 25 #>   Cross-validation error (deviance): 1.90 #>   Scale estimate (sigma): 1.380"},{"path":"/reference/svd_X.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to implement singular value decomposition for a PLMM or LMM\nThis is an internal function to plmm_prep() — svd_X","title":"A function to implement singular value decomposition for a PLMM or LMM\nThis is an internal function to plmm_prep() — svd_X","text":"function implement singular value decomposition PLMM LMM internal function plmm_prep()","code":""},{"path":"/reference/svd_X.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to implement singular value decomposition for a PLMM or LMM\nThis is an internal function to plmm_prep() — svd_X","text":"","code":"svd_X(X, k, trunc, trace)"},{"path":"/reference/svd_X.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to implement singular value decomposition for a PLMM or LMM\nThis is an internal function to plmm_prep() — svd_X","text":"X standardized design matrix k Optional integer argument indicating number singular values use truncated SVD. See details. trunc Logical: truncated SVD used? trace Logical: messages printed console?","code":""},{"path":"/reference/svd_X.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A function to implement singular value decomposition for a PLMM or LMM\nThis is an internal function to plmm_prep() — svd_X","text":"kind SVD implemented depend combination arguments supplied. (1) trunc = FALSE use base::svd(K) (2) trunc = TRUE use RSpectra::svds(K, k = k)","code":""},{"path":"/reference/untransform.html","id":null,"dir":"Reference","previous_headings":"","what":"Untransform coefficient values back to the original scale — untransform","title":"Untransform coefficient values back to the original scale — untransform","text":"function unwinds initial standardization data obtain coefficient values original scale. called plmm_format().","code":""},{"path":"/reference/untransform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Untransform coefficient values back to the original scale — untransform","text":"","code":"untransform(untransformed_b1, ns, p, std_X_details)"},{"path":"/reference/untransform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Untransform coefficient values back to the original scale — untransform","text":"untransformed_b1 estimated coefficients standardized scale ns indices non-singular columns ORIGINAL design matrix p number columns original design matrix (without intercept) std_X_details list 3 elements describing standardized design matrix rotation; elements 'scale', 'center', 'nonsingular'","code":""},{"path":"/reference/v_hat.html","id":null,"dir":"Reference","previous_headings":"","what":"a function to create the estimated variance matrix from a PLMM fit — v_hat","title":"a function to create the estimated variance matrix from a PLMM fit — v_hat","text":"function create estimated variance matrix PLMM fit","code":""},{"path":"/reference/v_hat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"a function to create the estimated variance matrix from a PLMM fit — v_hat","text":"","code":"v_hat(fit, K = NULL)"},{"path":"/reference/v_hat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"a function to create the estimated variance matrix from a PLMM fit — v_hat","text":"fit object returned plmm() K optional matrix list returned choose_K()","code":""},{"path":"/reference/v_hat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"a function to create the estimated variance matrix from a PLMM fit — v_hat","text":"Vhat, matrix representing estimated variance","code":""},{"path":"/reference/varp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the population variance — varp","title":"Calculate the population variance — varp","text":"function allows calculate population variance; assume sample population.","code":""},{"path":"/reference/varp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the population variance — varp","text":"","code":"varp(x)"},{"path":"/reference/varp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the population variance — varp","text":"x numeric vector","code":""},{"path":"/reference/varp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the population variance — varp","text":"","code":"if (FALSE) { v <- rnorm(5) varp(v) }"}]
