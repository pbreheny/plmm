% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict-plmm.R
\name{predict.plmm}
\alias{predict.plmm}
\title{Predict method for plmm class}
\usage{
\method{predict}{plmm}(
  object,
  newX,
  type = c("response", "coefficients", "vars", "nvars", "blup"),
  lambda,
  idx = 1:length(object$lambda),
  no_int_X,
  y,
  U,
  S,
  eta,
  covariance,
  ...
)
}
\arguments{
\item{object}{An object of class \code{plmm}.}

\item{newX}{Design matrix used for computing predicted values if requested.}

\item{type}{A character argument indicating what type of prediction should be returned. Options are "response," "coefficients," "vars," "nvars," and "blup." See details.}

\item{lambda}{A numeric vector of regularization parameter \code{lambda} values at which predictions are requested.}

\item{idx}{Vector of indices of the penalty parameter \code{lambda} at which predictions are required. By default, all indices are returned.}

\item{y}{Optional argument. Original continuous outcome vector from object. Required if \code{type == 'blup'}.}

\item{U}{Optional argument. Eigenvectors from the similarity matrix from object. Required if \code{type == 'blup'}.}

\item{S}{Optional argument. Eigenvalues from the similarity matrix from object. Required if \code{type == 'blup'}.}

\item{eta}{Optional argument. Estimated $eta$ value from object. Required if \code{type == 'blup'}.}

\item{covariance}{Optional argument. $q times n$ covariance matrix between new and old observations. Required if \code{type == 'blup'}.}

\item{...}{Additional optional arguments}

\item{X}{Optional argument. Original design matrix (not including intercept column) from object. Required if \code{type == 'blup'} and object is too large to be returned in \code{plmm} object.}
}
\description{
Predict method for plmm class
}
\examples{
# fit a model 
fit <- plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X))

# simulate new data 
newX <- sim_ps_x(n = nrow(admix$X), nJ = 4, p = ncol(admix$X),
 structureX = "independent", inbr = "heterogeneous", standardizeX = FALSE)
 
 # make predictions for all lambda values 
 pred1 <- predict(object = fit, newX = newX, type = "response")
 
 # make predictions for a select number of lambda values 
 pred2 <- predict(object = fit, newX = newX, type = "response", idx=98)
 
 # make prediction using blup 
 pred3 <- predict(object = fit, newX = newX, type = "blup", idx=98)

 # compare y predictions 
  compare_y <- data.frame(y = admix$y, yhat_response = pred2, yhat_blup = pred3)
 
 \dontrun{
 fit_noX <- plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X),
  returnX = FALSE)
 
 pred4 <- predict(object = fit_noX, newX = newX, type = "blup", idx=98)
 
 }
 
 # make predictions when X is big 
 # TODO: add an example here 
}
