% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict-plmm.R
\name{predict.plmm}
\alias{predict.plmm}
\title{Predict method for plmm class}
\usage{
\method{predict}{plmm}(
  object,
  newX,
  type = c("response", "coefficients", "vars", "nvars", "blup"),
  lambda,
  idx = 1:length(object$lambda),
  X,
  y,
  ...
)
}
\arguments{
\item{object}{An object of class \code{plmm}.}

\item{newX}{Design matrix used for computing predicted values if requested.}

\item{type}{A character argument indicating what type of prediction should be returned. Options are "response," "coefficients," "vars," "nvars," and "blup." See details.}

\item{lambda}{A numeric vector of regularization parameter \code{lambda} values at which predictions are requested.}

\item{idx}{Vector of indices of the penalty parameter \code{lambda} at which predictions are required. By default, all indices are returned.}

\item{X}{Optional argument. Original design matrix (not including intercept column) from object. Required if \code{type == 'blup'} and object is too large to be returned in \code{plmm} object.}

\item{y}{Optional argument. Original continuous outcome vector from object. Required if \code{type == 'blup'}.}

\item{...}{Additional optional arguments}

\item{U}{Optional argument. Eigenvectors from the similarity matrix from object. Required if \code{type == 'blup'}.}

\item{S}{Optional argument. Eigenvalues from the similarity matrix from object. Required if \code{type == 'blup'}.}

\item{eta}{Optional argument. Estimated $eta$ value from object. Required if \code{type == 'blup'}.}

\item{covariance}{Optional argument. $q times n$ covariance matrix between new and old observations. Required if \code{type == 'blup'}.}
}
\description{
Predict method for plmm class
}
\examples{
# fit a model 
fit <- plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X))

# simulate new data 
newX <- sim_ps_x(n = nrow(admix$X), nJ = 4, p = ncol(admix$X),
 structureX = "independent", inbr = "heterogeneous", standardizeX = FALSE)
 
 # make predictions for all lambda values 
 pred1 <- predict(object = fit, newX = newX, type = "response")
 
 # make predictions for a select number of lambda values 
 pred2 <- predict(object = fit, newX = newX, type = "response", idx=98)
 
 # make prediction using blup 
 pred3 <- predict(object = fit, newX = newX, type = "blup", idx=98)

 # compare y predictions 
  compare_y <- data.frame(y = admix$y, yhat_response = pred2, yhat_blup = pred3)
 
 \dontrun{
 fit_noX <- plmm(X = admix$X, y = admix$y, K = relatedness_mat(admix$X),
  returnX = FALSE)
 
 pred4 <- predict(object = fit_noX, newX = newX, type = "blup", idx=98)
 
 }
 
 
# make predictions when X is big
cad <- process_plink(prefix = "cad", dataDir = plink_example(path="cad.fam", parent=T))
cad_clinical <- read.csv(plink_example(path="cad_clinical.csv"))
# for the sake of illustration, I use a simple mean imputation for the outcome 
cad_clinical$hdl_impute <- ifelse(is.na(cad_clinical$hdl), mean(cad_clinical$hdl, na.rm = T), cad_clinical$hdl)
fit_cad <- plmm(X = cad$genotypes, y = cad_clinical$hdl_impute, k = 5)
cad_X <- cad$genotypes
cad_y <- cad_clinical$hdl_impute
newX_cad <- sim_ps_x(n = nrow(cad_X), nJ = 4, p = ncol(cad_X),
 structureX = "independent", inbr = "heterogeneous", standardizeX = FALSE)
pred_cad <- predict(object = fit_cad, newX = newX_cad, type='blup', idx = 95, X = cad_X, y = cad_y)
head(data.frame(cad_y, pred_cad))

 

}
